

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Documentation &mdash; swiftpol  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Getting Started" href="getting_started.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            swiftpol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html#getting-started-with-swiftpol">Getting Started with Swiftpol</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="#module-swiftpol.build">swiftpol.build</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.build.PDI"><code class="docutils literal notranslate"><span class="pre">PDI()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.build.blockiness_gen"><code class="docutils literal notranslate"><span class="pre">blockiness_gen()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.build.build_linear_copolymer"><code class="docutils literal notranslate"><span class="pre">build_linear_copolymer()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.build.build_polymer"><code class="docutils literal notranslate"><span class="pre">build_polymer()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.build.calculate_box_components"><code class="docutils literal notranslate"><span class="pre">calculate_box_components()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.build.polymer_system"><code class="docutils literal notranslate"><span class="pre">polymer_system</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.AllChem"><code class="docutils literal notranslate"><span class="pre">polymer_system.AllChem</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.ExactMolWt"><code class="docutils literal notranslate"><span class="pre">polymer_system.ExactMolWt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.box"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.box</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.collections"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.collections</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.combine"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.combine()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.from_foyer"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.from_foyer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.from_gromacs"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.from_gromacs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.from_openmm"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.from_openmm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.from_smirnoff"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.from_smirnoff()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.get_positions"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.get_positions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.mdconfig"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.mdconfig</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.minimize"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.minimize()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.model_computed_fields"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.model_computed_fields</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.model_config"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.model_config</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.model_fields"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.model_fields</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.positions"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.positions</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_amber"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_amber()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_crd"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_crd()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_gro"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_gro()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_gromacs"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_gromacs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_inpcrd"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_inpcrd()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_lammps"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_lammps()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_lammps_datafile"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_lammps_datafile()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_lammps_input"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_lammps_input()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_mdp"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_mdp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_openmm"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_openmm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_openmm_simulation"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_openmm_simulation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_openmm_system"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_openmm_system()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_openmm_topology"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_openmm_topology()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_pdb"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_pdb()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_prmtop"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_prmtop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_psf"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_psf()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_sander_input"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_sander_input()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.to_top"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.to_top()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.topology"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.topology</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.velocities"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.velocities</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange.visualize"><code class="docutils literal notranslate"><span class="pre">polymer_system.Interchange.visualize()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.SUPPORTED_CHARGE_METHODS"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.SUPPORTED_CHARGE_METHODS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.apply_elf_conformer_selection"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.apply_elf_conformer_selection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.assign_fractional_bond_orders"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.assign_fractional_bond_orders()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.assign_partial_charges"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.assign_partial_charges()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.atom_is_in_ring"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.atom_is_in_ring()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.bond_is_in_ring"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.bond_is_in_ring()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.canonical_order_atoms"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.canonical_order_atoms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_protomers"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.enumerate_protomers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_stereoisomers"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.enumerate_stereoisomers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_tautomers"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.enumerate_tautomers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.find_smarts_matches"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.find_smarts_matches()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_file"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_file_obj"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_file_obj()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_inchi"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_inchi()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_iupac"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_iupac()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_object"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_object()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_openeye"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_openeye()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_smiles"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.from_smiles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.generate_conformers"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.generate_conformers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.get_tagged_smarts_connectivity"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.get_tagged_smarts_connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.is_available"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.is_available()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_file"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_file_obj"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_file_obj()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_inchi"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_inchi()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_inchikey"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_inchikey()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_iupac"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_iupac()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_openeye"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_openeye()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_smiles"><code class="docutils literal notranslate"><span class="pre">polymer_system.OpenEyeToolkitWrapper.to_smiles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.PDI"><code class="docutils literal notranslate"><span class="pre">polymer_system.PDI()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.SUPPORTED_CHARGE_METHODS"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.SUPPORTED_CHARGE_METHODS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.apply_elf_conformer_selection"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.apply_elf_conformer_selection()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.assign_partial_charges"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.assign_partial_charges()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.atom_is_in_ring"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.atom_is_in_ring()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.bond_is_in_ring"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.bond_is_in_ring()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.canonical_order_atoms"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.canonical_order_atoms()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.enumerate_stereoisomers"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.enumerate_stereoisomers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.enumerate_tautomers"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.enumerate_tautomers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.find_smarts_matches"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.find_smarts_matches()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_file"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_file_obj"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_file_obj()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_inchi"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_inchi()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_object"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_object()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_pdb_and_smiles"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_pdb_and_smiles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_rdkit"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_rdkit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_smiles"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.from_smiles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.generate_conformers"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.generate_conformers()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.get_tagged_smarts_connectivity"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.get_tagged_smarts_connectivity()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.is_available"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.is_available()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_file"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.to_file()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_file_obj"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.to_file_obj()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_inchi"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.to_inchi()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_inchikey"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.to_inchikey()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_rdkit"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.to_rdkit()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_smiles"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.to_smiles()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.toolkit_file_write_formats"><code class="docutils literal notranslate"><span class="pre">polymer_system.RDKitToolkitWrapper.toolkit_file_write_formats</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.UNIT_CUBE"><code class="docutils literal notranslate"><span class="pre">polymer_system.UNIT_CUBE</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.blockiness_gen"><code class="docutils literal notranslate"><span class="pre">polymer_system.blockiness_gen()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.build_bulk"><code class="docutils literal notranslate"><span class="pre">polymer_system.build_bulk()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.build_polymer"><code class="docutils literal notranslate"><span class="pre">polymer_system.build_polymer()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.calculate_box_components"><code class="docutils literal notranslate"><span class="pre">polymer_system.calculate_box_components()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.charge_system"><code class="docutils literal notranslate"><span class="pre">polymer_system.charge_system()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.generate_conformers"><code class="docutils literal notranslate"><span class="pre">polymer_system.generate_conformers()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.mean"><code class="docutils literal notranslate"><span class="pre">polymer_system.mean()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.np"><code class="docutils literal notranslate"><span class="pre">polymer_system.np</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.oechem"><code class="docutils literal notranslate"><span class="pre">polymer_system.oechem</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.pack_box"><code class="docutils literal notranslate"><span class="pre">polymer_system.pack_box()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.reduce"><code class="docutils literal notranslate"><span class="pre">polymer_system.reduce()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.solvate_system"><code class="docutils literal notranslate"><span class="pre">polymer_system.solvate_system()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#swiftpol.build.polymer_system.unit"><code class="docutils literal notranslate"><span class="pre">polymer_system.unit</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#swiftpol-parameterize">swiftpol.parameterize</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.parameterize.charge_polymer"><code class="docutils literal notranslate"><span class="pre">charge_polymer()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#swiftpol.parameterize.forcefield_with_charge_handler"><code class="docutils literal notranslate"><span class="pre">forcefield_with_charge_handler()</span></code></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">swiftpol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-documentation">
<h1>API Documentation<a class="headerlink" href="#api-documentation" title="Link to this heading"></a></h1>
<table class="autosummary longtable docutils align-default">
<tbody>
</tbody>
</table>
</section>
<section id="module-swiftpol.build">
<span id="swiftpol-build"></span><h1>swiftpol.build<a class="headerlink" href="#module-swiftpol.build" title="Link to this heading"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="swiftpol.build.PDI">
<span class="sig-prename descclassname"><span class="pre">swiftpol.build.</span></span><span class="sig-name descname"><span class="pre">PDI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chains</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#PDI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.PDI" title="Link to this definition"></a></dt>
<dd><p>Calculates the Polydispersity Index (PDI), number-average molecular weight (Mn), and weight-average molecular weight (Mw) of a list of chains.</p>
<p>This function takes a list of molecular chains and calculates the PDI, which is the ratio of Mw to Mn. It also calculates Mn, which is the sum of the molecular weights of the chains divided by the number of chains, and Mw, which is the sum of the product of the weight fraction and molecular weight of each chain.</p>
<p>Parameters:
chains (list): A list of molecular chains. Each chain is represented as an RDkit molecule object.</p>
<p>Returns:
tuple: A tuple containing the PDI (float), Mn (float), and Mw (float).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="swiftpol.build.blockiness_gen">
<span class="sig-prename descclassname"><span class="pre">swiftpol.build.</span></span><span class="sig-name descname"><span class="pre">blockiness_gen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#blockiness_gen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.blockiness_gen" title="Link to this definition"></a></dt>
<dd><p>Calculate the blockiness and average block length of a co-polymer sequence.</p>
<p>This function calculates the blockiness of a co-polymer sequence by counting the occurrences of ‘GG’ and ‘GL’ or ‘LG’ in the sequence.
It also calculates the average block length of ‘G’ and ‘L’ in the sequence.</p>
<p>Parameters:
sequence (str): A string representing the co-polymer sequence. ‘G’ represents one type of monomer and ‘L’ represents another type.</p>
<p>Returns:
blockiness (float): The blockiness of the co-polymer sequence. Calculated as the ratio of ‘GG’ to ‘GL’ or ‘LG’.
block_length_G (float): The average block length of ‘G’ in the sequence.
block_length_L (float): The average block length of ‘L’ in the sequence.</p>
<p>If the sequence does not contain both ‘G’ and ‘L’, the function returns a string indicating that the molecule is not a co-polymer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="swiftpol.build.build_linear_copolymer">
<span class="sig-prename descclassname"><span class="pre">swiftpol.build.</span></span><span class="sig-name descname"><span class="pre">build_linear_copolymer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monomer_a_smiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monomer_b_smiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reaction=&lt;rdkit.Chem.rdChemReactions.ChemicalReaction</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#build_linear_copolymer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.build_linear_copolymer" title="Link to this definition"></a></dt>
<dd><p>Constructs a linear co-polymer from the provided sequence of monomers.</p>
<p>This function takes a sequence of monomers represented as ‘A’ and ‘B’, and the SMILES strings of two monomers. It constructs a co-polymer based on the sequence, using the provided reaction SMARTS for joining the monomers. The function returns the sanitized polymer and the percentage composition of each monomer in the polymer.</p>
<p>Parameters:
sequence (str): A string representing the sequence of monomers. ‘A’ represents monomer_a and ‘B’ represents monomer_b.
monomer_a_smiles (str): The SMILES string of monomer A.
monomer_b_smiles (str): The SMILES string of monomer B.
reaction (rdkit.Chem.rdChemReactions.ChemicalReaction, optional): The reaction SMARTS used for joining the monomers. Defaults to ‘[C:1][HO:2].[HO:3][C:4]&gt;&gt;[C:1][O:2][C:4].[O:3]’, representing a condensation polymerisation.</p>
<p>Returns:
tuple: A tuple containing the sanitized polymer (rdkit.Chem.rdchem.Mol), the percentage composition of monomer A (float), and the percentage composition of monomer B (float).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="swiftpol.build.build_polymer">
<span class="sig-prename descclassname"><span class="pre">swiftpol.build.</span></span><span class="sig-name descname"><span class="pre">build_polymer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monomer_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reaction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terminal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hydroxyl'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#build_polymer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.build_polymer" title="Link to this definition"></a></dt>
<dd><p>Constructs a polymer from a given sequence of monomers.</p>
<p>Parameters:
sequence (str): A string representing the sequence of monomers (e.g., ‘ABAB’).
monomer_list (list): A list of SMILES strings representing the monomers.
reaction (rdkit.Chem.rdChemReactions.ChemicalReaction): An RDKit reaction object used to link monomers.
terminal (str, optional): The terminal group to be added to the polymer. Options are ‘hydroxyl’, ‘carboxyl’, or ‘ester’. Default is ‘hydroxyl’.</p>
<p>Returns:
rdkit.Chem.rdchem.Mol: The constructed polymer as an RDKit molecule object.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="swiftpol.build.calculate_box_components">
<span class="sig-prename descclassname"><span class="pre">swiftpol.build.</span></span><span class="sig-name descname"><span class="pre">calculate_box_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chains</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monomers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt_concentration=&lt;Quantity(0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'mole</span> <span class="pre">/</span> <span class="pre">liter')&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_monomer=0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#calculate_box_components"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.calculate_box_components" title="Link to this definition"></a></dt>
<dd><p>ADAPTED FROM OPENFF TOOLKIT PACKMOL WRAPPER SOLVATE_TOPOLOGY FUNCTION
Calculates the components required to construct a simulation box for a given set of molecular chains.
Considers the salt concentration and residual monomer concentration to determine the quantity of each molecule type required.</p>
<p>Parameters:
chains (list): A list of molecular chains to be included in the simulation box.
sequence (str): A string representing the sequence of the molecular chains. ‘G’ and ‘L’ represent different types of monomers.
salt_concentration (float, optional): The desired salt concentration in the simulation box. Defaults to 0.1 M.
residual_monomer (float, optional): The desired residual monomer concentration in the simulation box. Defaults to 0.05.</p>
<p>Returns:
tuple: A tuple containing the following elements:</p>
<blockquote>
<div><ul class="simple">
<li><p>molecules (list): A list of molecules to be included in the simulation box.</p></li>
<li><p>number_of_copies (list): A list indicating the quantity of each molecule to be included in the simulation box.</p></li>
<li><p>topology (openff.toolkit.topology.Topology): The topology of the simulation box.</p></li>
<li><p>box_vectors (numpy.ndarray): The vectors defining the dimensions of the simulation box.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">swiftpol.build.</span></span><span class="sig-name descname"><span class="pre">polymer_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monomer_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reaction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length_target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_chains</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terminals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'standard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perc_A_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blockiness_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copolymer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acceptance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#polymer_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.polymer_system" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.AllChem">
<span class="sig-name descname"><span class="pre">AllChem</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;module</span> <span class="pre">'rdkit.Chem.AllChem'</span> <span class="pre">from</span> <span class="pre">'/opt/anaconda3/envs/polymer/lib/python3.11/site-packages/rdkit/Chem/AllChem.py'&gt;</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.AllChem" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.ExactMolWt">
<span class="sig-name descname"><span class="pre">ExactMolWt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.ExactMolWt" title="Link to this definition"></a></dt>
<dd><p>The exact molecular weight of the molecule</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ExactMolWt</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;CC&#39;</span><span class="p">))</span>
<span class="go">30.04...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExactMolWt</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;[13CH3]C&#39;</span><span class="p">))</span>
<span class="go">31.05...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Interchange</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">*,</span> <span class="pre">collections:</span> <span class="pre">~typing.Annotated[dict[str,</span> <span class="pre">~openff.interchange.components.potentials.Collection],</span> <span class="pre">~pydantic.functional_validators.WrapValidator(func=~openff.interchange.components.potentials.validate_collections,</span> <span class="pre">json_schema_input_type=PydanticUndefined)]</span> <span class="pre">=</span> <span class="pre">{},</span> <span class="pre">topology:</span> <span class="pre">~openff.toolkit.topology.topology.Annotated[~openff.toolkit.topology.topology.Topology,</span> <span class="pre">~pydantic.functional_validators.WrapValidator(func=~openff.interchange.serialization._topology_custom_before_validator,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_serializers.PlainSerializer(func=~openff.interchange.serialization._topology_dict_serializer,</span> <span class="pre">return_type=dict,</span> <span class="pre">when_used=always),</span> <span class="pre">~pydantic.functional_serializers.WrapSerializer(func=~openff.interchange.serialization._topology_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=json)],</span> <span class="pre">mdconfig:</span> <span class="pre">~openff.interchange.components.mdconfig.MDConfig</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">box:</span> <span class="pre">~pint.Annotated[~pint.Quantity,</span> <span class="pre">~pydantic.functional_validators.WrapValidator(func=~openff.interchange._annotations.quantity_validator,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_validators.AfterValidator(func=functools.partial(&lt;function</span> <span class="pre">_has_compatible_dimensionality</span> <span class="pre">at</span> <span class="pre">0x1511a3560&gt;,</span> <span class="pre">unit='nanometer',</span> <span class="pre">convert=False)),</span> <span class="pre">~pydantic.functional_validators.AfterValidator(func=~openff.interchange._annotations._is_box_shape),</span> <span class="pre">~pydantic.functional_validators.BeforeValidator(func=~openff.interchange._annotations._duck_to_nanometer,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_validators.BeforeValidator(func=~openff.interchange._annotations._unwrap_list_of_openmm_quantities,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_serializers.WrapSerializer(func=~openff.interchange._annotations.quantity_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=always)]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">positions:</span> <span class="pre">~pint.Annotated[~pint.Quantity,</span> <span class="pre">~pydantic.functional_validators.WrapValidator(func=~openff.interchange._annotations.quantity_validator,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_validators.AfterValidator(func=functools.partial(&lt;function</span> <span class="pre">_has_compatible_dimensionality</span> <span class="pre">at</span> <span class="pre">0x1511a3560&gt;,</span> <span class="pre">unit='nanometer',</span> <span class="pre">convert=True)),</span> <span class="pre">~pydantic.functional_validators.AfterValidator(func=~openff.interchange._annotations._is_positions_shape),</span> <span class="pre">~pydantic.functional_validators.BeforeValidator(func=~openff.interchange._annotations._duck_to_nanometer,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_serializers.WrapSerializer(func=~openff.interchange._annotations.quantity_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=always)]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">velocities:</span> <span class="pre">~pint.Annotated[~pint.Quantity,</span> <span class="pre">~pydantic.functional_validators.WrapValidator(func=~openff.interchange._annotations.quantity_validator,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">~pydantic.functional_validators.AfterValidator(func=functools.partial(&lt;function</span> <span class="pre">_has_compatible_dimensionality</span> <span class="pre">at</span> <span class="pre">0x1511a3560&gt;,</span> <span class="pre">unit='nanometer</span> <span class="pre">/</span> <span class="pre">picosecond',</span> <span class="pre">convert=False)),</span> <span class="pre">~pydantic.functional_serializers.WrapSerializer(func=~openff.interchange._annotations.quantity_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=always)]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_BaseModel</span></code></p>
<p>A object for storing, manipulating, and converting molecular mechanics data.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is not stable and subject to change.</p>
</div>
<p class="rubric">Examples</p>
<p>Create an <code class="docutils literal notranslate"><span class="pre">Interchange</span></code> from an OpenFF <code class="docutils literal notranslate"><span class="pre">ForceField</span></code> and <code class="docutils literal notranslate"><span class="pre">Molecule</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">ForceField</span><span class="p">,</span> <span class="n">Molecule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sage</span> <span class="o">=</span> <span class="n">ForceField</span><span class="p">(</span><span class="s2">&quot;openff-2.2.0.offxml&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="s2">&quot;CCC&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_topology</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interchange</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">create_interchange</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the parameters for the bond between atoms 0 and 1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interchange</span><span class="p">[</span><span class="s2">&quot;Bonds&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">Potential(...)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.box">
<span class="sig-name descname"><span class="pre">box</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">quantity_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=always)]</span> <span class="pre">|</span> <span class="pre">None</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.box" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.collections">
<span class="sig-name descname"><span class="pre">collections</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Annotated</span><span class="p"><span class="pre">[</span></span><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Collection</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">WrapValidator</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="pre">validate_collections</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">json_schema_input_type</span></span><span class="o"><span class="pre">=</span></span><span class="pre">PydanticUndefined</span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.collections" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.combine">
<span class="sig-name descname"><span class="pre">combine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="openff.interchange.components.interchange.Interchange"><span class="pre">Interchange</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="openff.interchange.components.interchange.Interchange"><span class="pre">Interchange</span></a></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.combine" title="Link to this definition"></a></dt>
<dd><p>Combine two Interchange objects. This method is unstable and not yet safe for general use.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.from_foyer">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_foyer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force_field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FoyerForcefield</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topology</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Topology</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="swiftpol.build.polymer_system.Interchange"><span class="pre">Interchange</span></a></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.from_foyer" title="Link to this definition"></a></dt>
<dd><p>Create an Interchange object from a Foyer force field and an OpenFF topology.</p>
<p class="rubric">Examples</p>
<p>Generate an Interchange object from a single-molecule (OpenFF) topology and
the Foyer implementation of OPLS-AA</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.interchange</span> <span class="kn">import</span> <span class="n">Interchange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">Molecule</span><span class="p">,</span> <span class="n">Topology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">foyer</span> <span class="kn">import</span> <span class="n">Forcefield</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="s2">&quot;CC&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">generate_conformers</span><span class="p">(</span><span class="n">n_conformers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">top</span> <span class="o">=</span> <span class="n">Topology</span><span class="o">.</span><span class="n">from_molecules</span><span class="p">([</span><span class="n">mol</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oplsaa</span> <span class="o">=</span> <span class="n">Forcefield</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;oplsaa&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interchange</span> <span class="o">=</span> <span class="n">Interchange</span><span class="o">.</span><span class="n">from_foyer</span><span class="p">(</span><span class="n">topology</span><span class="o">=</span><span class="n">top</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">oplsaa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interchange</span>
<span class="go">Interchange with 8 collections, non-periodic topology with 8 atoms.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.from_gromacs">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_gromacs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topology_file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gro_file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="openff.interchange.components.interchange.Interchange"><span class="pre">Interchange</span></a></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.from_gromacs" title="Link to this definition"></a></dt>
<dd><p>🧪 Create an Interchange object from GROMACS files.</p>
<div class="admonition-experimental admonition">
<p class="admonition-title">Experimental</p>
<p>This object is experimental and should not be used in production.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is experimental and not officially suitable for production.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is not stable and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>topology_file</strong> (<em>Path | str</em>) – The path to a GROMACS topology file.</p></li>
<li><p><strong>gro_file</strong> (<em>Path | str</em>) – The path to a GROMACS coordinate file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>interchange</strong> – An Interchange object representing the contents of the GROMACS files.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="swiftpol.build.polymer_system.Interchange">Interchange</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Bond parameters may not correctly be parsed, such as when using SMIRNOFF
force fields with hydrogen bond constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.from_openmm">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_openmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">openmm.System</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topology</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">openmm.app.Topology</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Topology</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Quantity</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box_vectors</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Quantity</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="swiftpol.build.polymer_system.Interchange"><span class="pre">Interchange</span></a></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.from_openmm" title="Link to this definition"></a></dt>
<dd><p>Create an Interchange object from OpenMM objects.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is not stable and subject to change.</p>
</div>
<p class="rubric">Notes</p>
<p>If (topological) bonds in water are missing (physics) parameters, as is often the case with
rigid water, these parameters will be filled in with values of 1 Angstrom equilibrium bond
length and a default force constant of 50,000 kcal/mol/A^2, representing an arbitrarily
stiff harmonic bond, and angle parameters of 104.5 degrees and 1.0 kcal/mol/rad^2,
representing an arbitrarily harmonic angle. It is expected that these values will be
overwritten by runtime MD options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<em>openmm.System</em>) – The OpenMM system.</p></li>
<li><p><strong>topology</strong> (<em>openmm.app.Topology, optional</em>) – The OpenMM topology.</p></li>
<li><p><strong>positions</strong> (<em>openmm.unit.Quantity or openff.units.Quantity, optional</em>) – The positions of particles in this system and/or topology.</p></li>
<li><p><strong>box_vectors</strong> (<em>openmm.unit.Quantity or openff.units.Quantity, optional</em>) – The vectors of the simulation box associated with this system and/or topology.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>interchange</strong> – An Interchange object representing the contents of the OpenMM objects.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="swiftpol.build.polymer_system.Interchange">Interchange</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.from_smirnoff">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_smirnoff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force_field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ForceField</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topology</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Topology</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Molecule</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charge_from_molecules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Molecule</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_bond_orders_from_molecules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Molecule</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_nonintegral_charges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#swiftpol.build.polymer_system.Interchange" title="openff.interchange.components.interchange.Interchange"><span class="pre">Interchange</span></a></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.from_smirnoff" title="Link to this definition"></a></dt>
<dd><p>Create a new object by parameterizing a topology with a SMIRNOFF force field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>force_field</strong> (<cite>openff.toolkit.ForceField</cite>) – The force field to parameterize the topology with.</p></li>
<li><p><strong>topology</strong> (<cite>openff.toolkit.Topology</cite> or <cite>List[openff.toolkit.Molecule]</cite>) – The topology to parameterize, or a list of molecules to construct a
topology from and parameterize.</p></li>
<li><p><strong>box</strong> (<cite>openff.units.Quantity</cite>, optional) – The box vectors associated with the <code class="docutils literal notranslate"><span class="pre">Interchange</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
box vectors are taken from the topology, if present.</p></li>
<li><p><strong>positions</strong> (<cite>openff.units.Quantity</cite>, optional) – The positions associated with atoms in the input topology. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
positions are taken from the molecules in topology, if present on all molecules.</p></li>
<li><p><strong>charge_from_molecules</strong> (<cite>List[openff.toolkit.molecule.Molecule]</cite>, optional) – If specified, partial charges will be taken from the given molecules
instead of being determined by the force field. In either case, charges
on the input topology are ignored.</p></li>
<li><p><strong>partial_bond_orders_from_molecules</strong> (<em>List[openff.toolkit.molecule.Molecule], optional</em>) – If specified, partial bond orders will be taken from the given molecules
instead of being determined by the force field.</p></li>
<li><p><strong>allow_nonintegral_charges</strong> (<em>bool, optional, default=False</em>) – If True, allow molecules to have approximately non-integral charges.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">Molecule</span></code> objects in the <code class="docutils literal notranslate"><span class="pre">topology</span></code> argument each contain
conformers, the returned <code class="docutils literal notranslate"><span class="pre">Interchange</span></code> object will have its positions
set via concatenating the 0th conformer of each <code class="docutils literal notranslate"><span class="pre">Molecule</span></code>.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">Molecule</span></code> objects in the <code class="docutils literal notranslate"><span class="pre">topology</span></code> argument have stored
partial charges, these are ignored and charges are assigned according to
the contents of the force field. To override the force field and use
preset charges, use the <code class="docutils literal notranslate"><span class="pre">charge_from_molecules</span></code> argument.</p>
<p class="rubric">Examples</p>
<p>Generate an Interchange object from a single-molecule (OpenFF) topology and
OpenFF 2.0.0 “Sage”</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">ForceField</span><span class="p">,</span> <span class="n">Molecule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="s2">&quot;CC&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">generate_conformers</span><span class="p">(</span><span class="n">n_conformers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sage</span> <span class="o">=</span> <span class="n">ForceField</span><span class="p">(</span><span class="s2">&quot;openff-2.0.0.offxml&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interchange</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">create_interchange</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">to_topology</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interchange</span>
<span class="go">Interchange with 7 collections, non-periodic topology with 8 atoms.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.get_positions">
<span class="sig-name descname"><span class="pre">get_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">include_virtual_sites</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Quantity</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.get_positions" title="Link to this definition"></a></dt>
<dd><p>Get the positions associated with this Interchange.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>include_virtual_sites</strong> (<em>bool, default=True</em>) – Include virtual sites in the returned positions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>positions</strong> – The positions of the atoms in the system.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>openff.units.Quantity</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.mdconfig">
<span class="sig-name descname"><span class="pre">mdconfig</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">MDConfig</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.mdconfig" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.minimize">
<span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">engine:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'openmm'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_tolerance:</span> <span class="pre">~pint.Quantity</span> <span class="pre">=</span> <span class="pre">&lt;Quantity(10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'kilojoule_per_mole</span> <span class="pre">/</span> <span class="pre">nanometer')&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.minimize" title="Link to this definition"></a></dt>
<dd><p>Minimize the energy of the system using an available engine.</p>
<p>Updates positions in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>engine</strong> (<em>str, default=”openmm”</em>) – The engine to use for minimization. Currently only “openmm” is supported.</p></li>
<li><p><strong>force_tolerance</strong> (<em>openff.units.Quantity, default=10.0 kJ / mol / nm</em>) – The force tolerance to run until during energy minimization.</p></li>
<li><p><strong>max_iterations</strong> (<em>int, default=10_000</em>) – The maximum number of iterations to run during energy minimization.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.model_computed_fields">
<span class="sig-name descname"><span class="pre">model_computed_fields</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ClassVar</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ComputedFieldInfo</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.model_computed_fields" title="Link to this definition"></a></dt>
<dd><p>A dictionary of computed field names and their corresponding <cite>ComputedFieldInfo</cite> objects.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.model_config">
<span class="sig-name descname"><span class="pre">model_config</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ClassVar</span><span class="p"><span class="pre">[</span></span><span class="pre">ConfigDict</span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'arbitrary_types_allowed':</span> <span class="pre">True,</span> <span class="pre">'validate_assignment':</span> <span class="pre">True}</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.model_config" title="Link to this definition"></a></dt>
<dd><p>Configuration for the model, should be a dictionary conforming to [<cite>ConfigDict</cite>][pydantic.config.ConfigDict].</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.model_fields">
<span class="sig-name descname"><span class="pre">model_fields</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ClassVar</span><span class="p"><span class="pre">[</span></span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">FieldInfo</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'box':</span> <span class="pre">FieldInfo(annotation=Union[Annotated[Quantity,</span> <span class="pre">WrapValidator,</span> <span class="pre">AfterValidator,</span> <span class="pre">AfterValidator,</span> <span class="pre">BeforeValidator,</span> <span class="pre">BeforeValidator,</span> <span class="pre">WrapSerializer],</span> <span class="pre">NoneType],</span> <span class="pre">required=False,</span> <span class="pre">default=None),</span> <span class="pre">'collections':</span> <span class="pre">FieldInfo(annotation=dict[str,</span> <span class="pre">Collection],</span> <span class="pre">required=False,</span> <span class="pre">default={},</span> <span class="pre">metadata=[WrapValidator(func=&lt;function</span> <span class="pre">validate_collections&gt;,</span> <span class="pre">json_schema_input_type=PydanticUndefined)]),</span> <span class="pre">'mdconfig':</span> <span class="pre">FieldInfo(annotation=Union[MDConfig,</span> <span class="pre">NoneType],</span> <span class="pre">required=False,</span> <span class="pre">default=None),</span> <span class="pre">'positions':</span> <span class="pre">FieldInfo(annotation=Union[Annotated[Quantity,</span> <span class="pre">WrapValidator,</span> <span class="pre">AfterValidator,</span> <span class="pre">AfterValidator,</span> <span class="pre">BeforeValidator,</span> <span class="pre">WrapSerializer],</span> <span class="pre">NoneType],</span> <span class="pre">required=False,</span> <span class="pre">default=None),</span> <span class="pre">'topology':</span> <span class="pre">FieldInfo(annotation=Topology,</span> <span class="pre">required=True,</span> <span class="pre">metadata=[WrapValidator(func=&lt;function</span> <span class="pre">_topology_custom_before_validator&gt;,</span> <span class="pre">json_schema_input_type=PydanticUndefined),</span> <span class="pre">PlainSerializer(func=&lt;function</span> <span class="pre">_topology_dict_serializer&gt;,</span> <span class="pre">return_type=&lt;class</span> <span class="pre">'dict'&gt;,</span> <span class="pre">when_used='always'),</span> <span class="pre">WrapSerializer(func=&lt;function</span> <span class="pre">_topology_json_serializer&gt;,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used='json')]),</span> <span class="pre">'velocities':</span> <span class="pre">FieldInfo(annotation=Union[Annotated[Quantity,</span> <span class="pre">WrapValidator,</span> <span class="pre">AfterValidator,</span> <span class="pre">WrapSerializer],</span> <span class="pre">NoneType],</span> <span class="pre">required=False,</span> <span class="pre">default=None)}</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.model_fields" title="Link to this definition"></a></dt>
<dd><p>Metadata about the fields defined on the model,
mapping of field names to [<cite>FieldInfo</cite>][pydantic.fields.FieldInfo] objects.</p>
<p>This replaces <cite>Model.__fields__</cite> from Pydantic V1.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.positions">
<span class="sig-name descname"><span class="pre">positions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">quantity_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=always)]</span> <span class="pre">|</span> <span class="pre">None</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.positions" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_amber">
<span class="sig-name descname"><span class="pre">to_amber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_amber" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange object to Amber files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prefix</strong> (<em>str</em>) – The prefix to use for the Amber parameter/topology, coordinate, and run files, i.e.
“foo” will produce “foo.top”, “foo.gro”, and “foo_pointenergy.in”.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The run input file is configured for a single-point energy calculation with sander. It is
likely portable to pmemd with little or no work.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_crd">
<span class="sig-name descname"><span class="pre">to_crd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_crd" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to a CHARMM-style .crd file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_gro">
<span class="sig-name descname"><span class="pre">to_gro</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_gro" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange object to a GROMACS coordinate file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> (<em>Path | str</em>) – The path to the GROMACS coordinate file to write.</p></li>
<li><p><strong>decimal</strong> (<em>int, default=3</em>) – The number of decimal places to use when writing the GROMACS coordinate file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Residue IDs must be positive integers (or string representations thereof).</p>
<p>Residue IDs greater than 99,999 are reduced modulo 100,000 in line with common GROMACS practice.</p>
<p>Residue names and IDs from the topology are used, if present, and otherwise are generated internally.</p>
<p>Behavior when some, but not all, residue names and IDs are present in the topology is undefined.</p>
<p>If residue IDs are generated internally, they are assigned sequentially to each molecule starting at 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_gromacs">
<span class="sig-name descname"><span class="pre">to_gromacs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogen_mass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Gt</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">gt</span></span><span class="o"><span class="pre">=</span></span><span class="m"><span class="pre">0</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.007947</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_merge_atom_types</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_gromacs" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange object to GROMACS files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prefix</strong> (<em>str</em>) – The prefix to use for the GROMACS topology and coordinate files, i.e. “foo” will produce
“foo.top”, “foo.gro”, and “foo_pointenergy.mdp”.</p></li>
<li><p><strong>decimal</strong> (<em>int, default=3</em>) – The number of decimal places to use when writing the GROMACS coordinate file.</p></li>
<li><p><strong>hydrogen_mass</strong> (<em>PostitiveFloat, default=1.007947</em>) – The mass to use for hydrogen atoms if not present in the topology. If non-trivially different
than the default value, mass will be transferred from neighboring heavy atoms. Note that this is currently
not applied to any waters and is unsupported when virtual sites are present.</p></li>
<li><p><strong>_merge_atom_types</strong> (<em>bool, default = False</em>) – The flag to define behaviour of GROMACSWriter. If True, then similar atom types will be merged.
If False, each atom will have its own atom type.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Molecule names in written files are not guaranteed to match the <cite>Moleclue.name</cite> attribute of the
molecules in the topology, especially if they are empty strings or not unique.</p>
<p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_gro</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_top</span></code> for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_inpcrd">
<span class="sig-name descname"><span class="pre">to_inpcrd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_inpcrd" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to an Amber .inpcrd file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_lammps">
<span class="sig-name descname"><span class="pre">to_lammps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_lammps" title="Link to this definition"></a></dt>
<dd><p>Export this <code class="docutils literal notranslate"><span class="pre">Interchange</span></code> to LAMMPS data and run input files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prefix</strong> – The prefix to use for the LAMMPS data and run input files. For
example, “foo” will produce files named “foo.lmp” and
“foo_pointenergy.in”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_lammps_datafile">
<span class="sig-name descname"><span class="pre">to_lammps_datafile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_lammps_datafile" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to a LAMMPS data file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_lammps_input">
<span class="sig-name descname"><span class="pre">to_lammps_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_lammps_input" title="Link to this definition"></a></dt>
<dd><p>Write a LAMMPS run input file for a single-point energy calculation.</p>
<p>LAMMPS considers many of the simulation parameters specified by an
<code class="docutils literal notranslate"><span class="pre">Interchange</span></code> to be run configuration options rather than features of
the force field. These options are set in the run input file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – The path to the created LAMMPS run input file</p></li>
<li><p><strong>data_file</strong> – The path to the LAMMPS data file that should be read by the input
file. If not given, <code class="docutils literal notranslate"><span class="pre">file_path</span></code> with the extension <code class="docutils literal notranslate"><span class="pre">.lmp</span></code> will
be used.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_mdp">
<span class="sig-name descname"><span class="pre">to_mdp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_mdp" title="Link to this definition"></a></dt>
<dd><p>Write a GROMACS run configuration <code class="docutils literal notranslate"><span class="pre">.MDP</span></code> file for a single-point energy.</p>
<p>GROMACS considers many of the simulation parameters specified by an
<code class="docutils literal notranslate"><span class="pre">Interchange</span></code> to be run configuration options rather than features of
the topology. These options are set in the <code class="docutils literal notranslate"><span class="pre">.MDP</span></code> file. The written
<code class="docutils literal notranslate"><span class="pre">.MDP</span></code> file includes the appropriate non-bonded configuration for the
<code class="docutils literal notranslate"><span class="pre">Interchange</span></code>. The <code class="docutils literal notranslate"><span class="pre">nsteps</span></code>, <code class="docutils literal notranslate"><span class="pre">nstenergy</span></code>, and <code class="docutils literal notranslate"><span class="pre">continuation</span></code>
configuration values are configured for a single-point energy
calculation and may be changed as appropriate to perform other
calculations. See the <a class="reference external" href="https://manual.gromacs.org/documentation/current/user-guide/mdp-options.html">GROMACS documentation</a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_path</strong> – The path to the created GROMACS <code class="docutils literal notranslate"><span class="pre">.MDP</span></code> file</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_openmm">
<span class="sig-name descname"><span class="pre">to_openmm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_openmm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_openmm_simulation">
<span class="sig-name descname"><span class="pre">to_openmm_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integrator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">openmm.Integrator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine_nonbonded_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_constrained_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ewald_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogen_mass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Gt</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">gt</span></span><span class="o"><span class="pre">=</span></span><span class="m"><span class="pre">0</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.007947</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">openmm.Force</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">openmm.app.simulation.Simulation</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_openmm_simulation" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to an OpenMM <code class="docutils literal notranslate"><span class="pre">Simulation</span></code> object.</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code> encapsulates
all the information needed for a typical OpenMM simulation into a single
object with a simple API.</p>
<p>Positions are set on the <code class="docutils literal notranslate"><span class="pre">Simulation</span></code> if present on the
<code class="docutils literal notranslate"><span class="pre">Interchange</span></code>.</p>
<p>Additional forces, such as a barostat, should be added with the
<code class="docutils literal notranslate"><span class="pre">additional_forces</span></code> argument to avoid having to re-initialize
the <code class="docutils literal notranslate"><span class="pre">Context</span></code>. Re-initializing the <code class="docutils literal notranslate"><span class="pre">Context</span></code> after adding a
<code class="docutils literal notranslate"><span class="pre">Force</span></code> is necessary due to <a class="reference external" href="https://github.com/openmm/openmm/wiki/Frequently-Asked-Questions#why-does-it-ignore-changes-i-make-to-a-system-or-force">implementation details</a>
in OpenMM.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>integrator</strong> (<em>subclass of openmm.Integrator</em>) – The integrator to use for the simulation.</p></li>
<li><p><strong>combine_nonbonded_forces</strong> (<em>bool, default=False</em>) – If True, an attempt will be made to combine all non-bonded interactions into a single
openmm.NonbondedForce.
If False, non-bonded interactions will be split across multiple forces.</p></li>
<li><p><strong>add_constrained_forces</strong> (<em>bool, default=False,</em>) – If True, add valence forces that might be overridden by constraints, i.e. call <cite>addBond</cite> or <cite>addAngle</cite>
on a bond or angle that is fully constrained.</p></li>
<li><p><strong>ewald_tolerance</strong> (<em>float, default=1e-4</em>) – The value passed to <cite>NonbondedForce.setEwaldErrorTolerance</cite></p></li>
<li><p><strong>hydrogen_mass</strong> (<em>PostitiveFloat, default=1.007947</em>) – The mass to use for hydrogen atoms if not present in the topology. If non-trivially different
than the default value, mass will be transferred from neighboring heavy atoms. Note that this is currently
not applied to any waters and is unsupported when virtual sites are present.</p></li>
<li><p><strong>additional_forces</strong> (<em>Iterable[openmm.Force], default=tuple()</em>) – Additional forces to be added to the system, e.g. barostats, that are not
added by the force field.</p></li>
<li><p><strong>**kwargs</strong> – Further keyword parameters are passed on to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.__init__()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>simulation</strong> – The OpenMM simulation object, possibly with positions set.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>openmm.app.Simulation</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create an OpenMM simulation with a Langevin integrator and a Monte Carlo barostat:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">openmm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">openmm.unit</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrator</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">LangevinMiddleIntegrator</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mf">293.15</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">1.0</span> <span class="o">/</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">2.0</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">femtosecond</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">barostat</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">MonteCarloBarostat</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mf">1.00</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">bar</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mf">293.15</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mi">25</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simulation</span> <span class="o">=</span> <span class="n">interchange</span><span class="o">.</span><span class="n">to_openmm_simulation</span><span class="p">(</span>  
<span class="gp">... </span>    <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">additional_forces</span><span class="o">=</span><span class="p">[</span><span class="n">barostat</span><span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_openmm_system">
<span class="sig-name descname"><span class="pre">to_openmm_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combine_nonbonded_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_constrained_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ewald_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogen_mass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Gt</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">gt</span></span><span class="o"><span class="pre">=</span></span><span class="m"><span class="pre">0</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.007947</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_openmm_system" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to an OpenMM System.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>combine_nonbonded_forces</strong> (<em>bool, default=True</em>) – If True, an attempt will be made to combine all non-bonded interactions into a single
openmm.NonbondedForce.
If False, non-bonded interactions will be split across multiple forces.</p></li>
<li><p><strong>add_constrained_forces</strong> (<em>bool, default=False,</em>) – If True, add valence forces that might be overridden by constraints, i.e. call <cite>addBond</cite> or <cite>addAngle</cite>
on a bond or angle that is fully constrained.</p></li>
<li><p><strong>ewald_tolerance</strong> (<em>float, default=1e-4</em>) – The value passed to <cite>NonbondedForce.setEwaldErrorTolerance</cite></p></li>
<li><p><strong>hydrogen_mass</strong> (<em>PostitiveFloat, default=1.007947</em>) – The mass to use for hydrogen atoms if not present in the topology. If non-trivially different
than the default value, mass will be transferred from neighboring heavy atoms. Note that this is currently
not applied to any waters and is unsupported when virtual sites are present.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>system</strong> – The OpenMM System object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>openmm.System</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>There are some sharp edges and quirks when using this method. Be aware of some documented
issues in the <span class="xref std std-doc">/using/edges</span> section of the user guide. If you encounter surprising
behavior that is not documented, please raise an issue.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_openmm_topology">
<span class="sig-name descname"><span class="pre">to_openmm_topology</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">collate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensure_unique_atom_names</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'residues'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_openmm_topology" title="Link to this definition"></a></dt>
<dd><p>Export components of this Interchange to an OpenMM Topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>collate</strong> – If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the default, all virtual sites will be added to a
single residue at the end of the topology. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, virtual
sites will be collated with their associated molecule and added to
the residue of the last atom in the molecule they belong to.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_pdb">
<span class="sig-name descname"><span class="pre">to_pdb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_virtual_sites</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_pdb" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to a .pdb file.</p>
<p>Note that virtual sites are collated into each molecule, which differs from the default
behavior of Interchange.to_openmm_topology.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_prmtop">
<span class="sig-name descname"><span class="pre">to_prmtop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_prmtop" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to an Amber .prmtop file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_psf">
<span class="sig-name descname"><span class="pre">to_psf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_psf" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to a CHARMM-style .psf file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_sander_input">
<span class="sig-name descname"><span class="pre">to_sander_input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_sander_input" title="Link to this definition"></a></dt>
<dd><p>Export this <code class="docutils literal notranslate"><span class="pre">Interchange</span></code> to a run input file for Amber’s SANDER engine.</p>
<p>Amber considers many of the simulation parameters specified by an
<code class="docutils literal notranslate"><span class="pre">Interchange</span></code> to be run configuration options rather than parameters
of the topology. These options are set in the SANDER or PMEMD run input
file. The written SANDER input file includes the appropriate non-bonded
configuration for the <code class="docutils literal notranslate"><span class="pre">Interchange</span></code> which are essential to reproduce
the desired force field. The file also includes configuration for a
single-point energy calculation, which should be modified to produce the
desired simulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.to_top">
<span class="sig-name descname"><span class="pre">to_top</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Path</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogen_mass</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Gt</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">gt</span></span><span class="o"><span class="pre">=</span></span><span class="m"><span class="pre">0</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.007947</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_merge_atom_types</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.to_top" title="Link to this definition"></a></dt>
<dd><p>Export this Interchange to a GROMACS topology file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – The path to the GROMACS topology file to write.</p></li>
<li><p><strong>hydrogen_mass</strong> (<em>PostitiveFloat, default=1.007947</em>) – The mass to use for hydrogen atoms if not present in the topology. If non-trivially different
than the default value, mass will be transferred from neighboring heavy atoms. Note that this is currently
not applied to any waters and is unsupported when virtual sites are present.</p></li>
<li><p><strong>_merge_atom_types</strong> (<em>book, default=False</em>) – The flag to define behaviour of GROMACSWriter. If True, then similar atom types will be merged.
If False, each atom will have its own atom type.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Molecule names in written files are not guaranteed to match the <cite>Moleclue.name</cite> attribute of the
molecules in the topology, especially if they are empty strings or not unique.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.topology">
<span class="sig-name descname"><span class="pre">topology</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Annotated</span><span class="p"><span class="pre">[</span></span><span class="pre">Topology</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">WrapValidator</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="pre">_topology_custom_before_validator</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">json_schema_input_type</span></span><span class="o"><span class="pre">=</span></span><span class="pre">PydanticUndefined</span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">PlainSerializer</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="pre">_topology_dict_serializer</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="pre">dict</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">when_used</span></span><span class="o"><span class="pre">=</span></span><span class="pre">always</span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">WrapSerializer</span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="pre">_topology_json_serializer</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">return_type</span></span><span class="o"><span class="pre">=</span></span><span class="pre">PydanticUndefined</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="n"><span class="pre">when_used</span></span><span class="o"><span class="pre">=</span></span><span class="pre">json</span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.topology" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.velocities">
<span class="sig-name descname"><span class="pre">velocities</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">quantity_json_serializer,</span> <span class="pre">return_type=PydanticUndefined,</span> <span class="pre">when_used=always)]</span> <span class="pre">|</span> <span class="pre">None</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.velocities" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.Interchange.visualize">
<span class="sig-name descname"><span class="pre">visualize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'nglview'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_virtual_sites</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">NGLWidget</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.Interchange.visualize" title="Link to this definition"></a></dt>
<dd><p>Visualize this Interchange.</p>
<p>This currently only uses NGLview. Other engines may be added in the future.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>backend</strong> (<em>str, default=”nglview”</em>) – The backend to use for visualization. Currently only “nglview” is supported.</p></li>
<li><p><strong>include_virtual_sites</strong> (<em>bool, default=False</em>) – Whether or not to include virtual sites in the visualization.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>widget</strong> – The NGLWidget containing the visualization.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nglview.NGLWidget</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">OpenEyeToolkitWrapper</span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToolkitWrapper</span></code></p>
<p>OpenEye toolkit wrapper</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.SUPPORTED_CHARGE_METHODS">
<span class="sig-name descname"><span class="pre">SUPPORTED_CHARGE_METHODS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'am1-mulliken':</span> <span class="pre">{'max_confs':</span> <span class="pre">1,</span> <span class="pre">'min_confs':</span> <span class="pre">1,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEAM1Charges',</span> <span class="pre">'rec_confs':</span> <span class="pre">1},</span> <span class="pre">'am1bcc':</span> <span class="pre">{'max_confs':</span> <span class="pre">1,</span> <span class="pre">'min_confs':</span> <span class="pre">1,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEAM1BCCCharges',</span> <span class="pre">'rec_confs':</span> <span class="pre">1},</span> <span class="pre">'am1bccelf10':</span> <span class="pre">{'max_confs':</span> <span class="pre">None,</span> <span class="pre">'min_confs':</span> <span class="pre">1,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEAM1BCCELF10Charges',</span> <span class="pre">'rec_confs':</span> <span class="pre">500},</span> <span class="pre">'am1bccnosymspt':</span> <span class="pre">{'max_confs':</span> <span class="pre">1,</span> <span class="pre">'min_confs':</span> <span class="pre">1,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEAM1BCCCharges',</span> <span class="pre">'rec_confs':</span> <span class="pre">1},</span> <span class="pre">'am1elf10':</span> <span class="pre">{'max_confs':</span> <span class="pre">None,</span> <span class="pre">'min_confs':</span> <span class="pre">1,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEELFCharges',</span> <span class="pre">'rec_confs':</span> <span class="pre">500},</span> <span class="pre">'gasteiger':</span> <span class="pre">{'max_confs':</span> <span class="pre">0,</span> <span class="pre">'min_confs':</span> <span class="pre">0,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEGasteigerCharges',</span> <span class="pre">'rec_confs':</span> <span class="pre">0},</span> <span class="pre">'mmff94':</span> <span class="pre">{'max_confs':</span> <span class="pre">0,</span> <span class="pre">'min_confs':</span> <span class="pre">0,</span> <span class="pre">'oe_charge_method':</span> <span class="pre">'OEMMFF94Charges',</span> <span class="pre">'rec_confs':</span> <span class="pre">0}}</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.SUPPORTED_CHARGE_METHODS" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.apply_elf_conformer_selection">
<span class="sig-name descname"><span class="pre">apply_elf_conformer_selection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.apply_elf_conformer_selection" title="Link to this definition"></a></dt>
<dd><p>Applies the <a class="reference external" href="https://docs.eyesopen.com/toolkits/python/quacpactk/molchargetheory.html#elf-conformer-selection">ELF method</a>
to select a set of diverse
conformers which have minimal electrostatically strongly interacting functional
groups from a molecules conformers.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input molecule should have a large set of conformers already
generated to select the ELF conformers from.</p></li>
<li><p>The selected conformers will be retained in the <code class="docutils literal notranslate"><span class="pre">molecule.conformers</span></code> list
while unselected conformers will be discarded.</p></li>
<li><p>Conformers generated with the OpenEye toolkit often include trans
carboxylic acids (COOH). These are unphysical and will be rejected by
<code class="docutils literal notranslate"><span class="pre">apply_elf_conformer_selection</span></code>. If no conformers are selected, try
re-running <code class="docutils literal notranslate"><span class="pre">generate_conformers</span></code> with the <code class="docutils literal notranslate"><span class="pre">make_carboxylic_acids_cis</span></code>
argument set to <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RDKitToolkitWrapper.apply_elf_conformer_selection</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule which contains the set of conformers to select from.</p></li>
<li><p><strong>percentage</strong> – The percentage of conformers with the lowest electrostatic interaction
energies to greedily select from.</p></li>
<li><p><strong>limit</strong> – The maximum number of conformers to select.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.assign_fractional_bond_orders">
<span class="sig-name descname"><span class="pre">assign_fractional_bond_orders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_order_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Quantity</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.assign_fractional_bond_orders" title="Link to this definition"></a></dt>
<dd><p>Update and store list of bond orders this molecule. Bond orders are stored on each
bond, in the <cite>bond.fractional_bond_order</cite> attribute.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to assign wiberg bond orders to</p></li>
<li><p><strong>bond_order_model</strong> – The charge model to use. One of [‘am1-wiberg’, ‘am1-wiberg-elf10’,
‘pm3-wiberg’, ‘pm3-wiberg-elf10’]. If None, ‘am1-wiberg’ will be used.</p></li>
<li><p><strong>use_conformers</strong> – The conformers to use for fractional bond order calculation. If None, an
appropriate number of conformers will be generated by an available
ToolkitWrapper. If the chosen <code class="docutils literal notranslate"><span class="pre">bond_order_model</span></code> is an ELF variant, the ELF
conformer selection method will be applied to the provided conformers.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.assign_partial_charges">
<span class="sig-name descname"><span class="pre">assign_partial_charges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_charge_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Quantity</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_n_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_partial_charges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.assign_partial_charges" title="Link to this definition"></a></dt>
<dd><p>Compute partial charges with OpenEye quacpac, and assign
the new values to the partial_charges attribute.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – Molecule for which partial charges are to be computed</p></li>
<li><p><strong>partial_charge_method</strong> – The charge model to use. One of [‘amberff94’, ‘mmff’, ‘mmff94’, ‘am1-mulliken’, ‘am1bcc’,
‘am1bccnosymspt’, ‘am1bccelf10’, ‘gasteiger’]
If None, ‘am1-mulliken’ will be used.</p></li>
<li><p><strong>use_conformers</strong> – shape (n_atoms, 3) and dimension of distance. Optional, default = None
Coordinates to use for partial charge calculation. If None, an appropriate number
of conformers will be generated.</p></li>
<li><p><strong>strict_n_conformers</strong> – Whether to raise an exception if an invalid number of conformers is provided for the
given charge method.
If this is False and an invalid number of conformers is found, a warning will be raised.</p></li>
<li><p><strong>normalize_partial_charges</strong> – Whether to offset partial charges so that they sum to the total formal charge of the molecule.
This is used to prevent accumulation of rounding errors when the partial charge generation method has
low precision.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ChargeMethodUnavailableError if the requested charge method can not be handled by this toolkit</strong> – </p></li>
<li><p><strong>ChargeCalculationError if the charge method is supported by this toolkit</strong><strong>, </strong><strong>but fails</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.atom_is_in_ring">
<span class="sig-name descname"><span class="pre">atom_is_in_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atom</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.atom_is_in_ring" title="Link to this definition"></a></dt>
<dd><p>Return whether or not an atom is in a ring.</p>
<p>It is assumed that this atom is in molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atom</strong> – The molecule containing the atom of interest</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether or not the atom is in a ring.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>is_in_ring</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotAttachedToMoleculeError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.bond_is_in_ring">
<span class="sig-name descname"><span class="pre">bond_is_in_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bond</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Bond</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.bond_is_in_ring" title="Link to this definition"></a></dt>
<dd><p>Return whether or not a bond is in a ring.</p>
<p>It is assumed that this atom is in molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bond</strong> – The molecule containing the atom of interest</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether or not the bond of index <cite>bond_index</cite> is in a ring</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>is_in_ring</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotAttachedToMoleculeError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.canonical_order_atoms">
<span class="sig-name descname"><span class="pre">canonical_order_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FrozenMolecule</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FrozenMolecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.canonical_order_atoms" title="Link to this definition"></a></dt>
<dd><p>Canonical order the atoms in the molecule using the OpenEye toolkit.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>molecule</strong> –    The input molecule</p>
<p>Returns</p>
</li>
<li><p><strong>——-</strong></p></li>
<li><p><strong>molecule</strong> – The input molecule, with canonically-indexed atoms and bonds.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_protomers">
<span class="sig-name descname"><span class="pre">enumerate_protomers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FrozenMolecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">FrozenMolecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_protomers" title="Link to this definition"></a></dt>
<dd><p>Enumerate the formal charges of a molecule to generate different protomers.
Note that, in cases where the input molecule has an uncommon protonation state
(for example <code class="docutils literal notranslate"><span class="pre">[NH2-]</span></code>), the input molecule may not be included in the output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule whose state we should enumerate</p></li>
<li><p><strong>max_states</strong> – The maximum number of protomer states to be returned. If 0, the default,
attempt to return all protomers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of the protomers of the input molecules, including the input molecule if found
by Quacpac and not pruned by <cite>max_states</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_stereoisomers">
<span class="sig-name descname"><span class="pre">enumerate_stereoisomers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FrozenMolecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undefined_only</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_isomers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rationalise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">FrozenMolecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_stereoisomers" title="Link to this definition"></a></dt>
<dd><p>Enumerate the stereocenters and bonds of the current molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule whose state we should enumerate</p></li>
<li><p><strong>undefined_only</strong> – If we should enumerate all stereocenters and bonds or only those with undefined stereochemistry</p></li>
<li><p><strong>max_isomers</strong> – The maximum amount of molecules that should be returned</p></li>
<li><p><strong>rationalise</strong> – If we should try to build and rationalise the molecule to ensure it can exist</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of openff.toolkit.topology.Molecule instances</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_tautomers">
<span class="sig-name descname"><span class="pre">enumerate_tautomers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FrozenMolecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">FrozenMolecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.enumerate_tautomers" title="Link to this definition"></a></dt>
<dd><p>Enumerate the possible tautomers of the current molecule</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule whose state we should enumerate</p></li>
<li><p><strong>max_states</strong> – The maximum amount of molecules that should be returned</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of openff.toolkit.topology.Molecule instances excluding the input molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.find_smarts_matches">
<span class="sig-name descname"><span class="pre">find_smarts_matches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smarts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aromaticity_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'OEAroModel_MDL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.find_smarts_matches" title="Link to this definition"></a></dt>
<dd><p>Find all SMARTS matches for the specified molecule, using the specified aromaticity model.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule for which all specified SMARTS matches are to be located</p></li>
<li><p><strong>smarts</strong> – SMARTS string with optional SMIRKS-style atom tagging</p></li>
<li><p><strong>aromaticity_model</strong> – The aromaticity model to use. Only OEAroModel_MDL is supported.</p></li>
<li><p><strong>unique</strong> – If True, only return unique matches. If False, return all matches.</p></li>
<li><p><strong>.. note :: Currently, the only supported ``aromaticity_model`` is ``OEAroModel_MDL``</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_file">
<span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">FrozenMolecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_file" title="Link to this definition"></a></dt>
<dd><p>Return an openff.toolkit.topology.Molecule from a file using this toolkit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – The file to read the molecule from</p></li>
<li><p><strong>file_format</strong> – Format specifier, usually file suffix (eg. ‘MOL2’, ‘SMI’)
Note that not all toolkits support all formats. Check ToolkitWrapper.toolkit_file_read_formats for details.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if oemol contains undefined stereochemistry.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of <code class="docutils literal notranslate"><span class="pre">Molecule</span></code> objects in the file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>GAFFAtomTypeWarning</strong> – If the loaded mol2 file possibly uses GAFF atom types, which
    are not supported.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Load a mol2 file into an OpenFF <code class="docutils literal notranslate"><span class="pre">Molecule</span></code> object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit.utils</span> <span class="kn">import</span> <span class="n">get_data_file_path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol2_file_path</span> <span class="o">=</span> <span class="n">get_data_file_path</span><span class="p">(</span><span class="s1">&#39;molecules/cyclohexane.mol2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">mol2_file_path</span><span class="p">,</span> <span class="n">file_format</span><span class="o">=</span><span class="s1">&#39;mol2&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_file_obj">
<span class="sig-name descname"><span class="pre">from_file_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Molecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_file_obj" title="Link to this definition"></a></dt>
<dd><p>Return an openff.toolkit.topology.Molecule from a file-like object (an object with a “.read()” method using
this toolkit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> – The file-like object to read the molecule from</p></li>
<li><p><strong>file_format</strong> – Format specifier, usually file suffix (eg. ‘MOL2’, ‘SMI’)
Note that not all toolkits support all formats. Check ToolkitWrapper.toolkit_file_read_formats for details.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if oemol contains undefined stereochemistry.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The list of Molecule objects in the file object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>GAFFAtomTypeWarning</strong> – If the loaded mol2 file possibly uses GAFF atom types, which
    are not supported.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_inchi">
<span class="sig-name descname"><span class="pre">from_inchi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inchi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FrozenMolecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_inchi" title="Link to this definition"></a></dt>
<dd><p>Construct a Molecule from a InChI representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inchi</strong> – The InChI representation of the molecule.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept InChI with undefined stereochemistry. If False,
an exception will be raised if a InChI with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
<li><p><strong>name</strong> – An optional name for the output molecule</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_iupac">
<span class="sig-name descname"><span class="pre">from_iupac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iupac_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FrozenMolecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_iupac" title="Link to this definition"></a></dt>
<dd><p>Construct a Molecule from an IUPAC name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iupac_name</strong> – The IUPAC or common name of the molecule.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept a molecule name with undefined stereochemistry. If False,
an exception will be raised if a molecule name with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_object">
<span class="sig-name descname"><span class="pre">from_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FrozenMolecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_object" title="Link to this definition"></a></dt>
<dd><p>Convert an OEMol (or OEMol-derived object) into an openff.toolkit.topology.molecule</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – An object to by type-checked.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept molecules with undefined stereocenters. If False,
an exception will be raised if a molecule with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An openff.toolkit.topology.molecule Molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Molecule</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – If the object could not be converted into a Molecule.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_openeye">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_openeye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oemol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FrozenMolecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_openeye" title="Link to this definition"></a></dt>
<dd><p>Create a Molecule from an OpenEye molecule. If the OpenEye molecule has
implicit hydrogens, this function will make them explicit.</p>
<p><code class="docutils literal notranslate"><span class="pre">OEAtom</span></code> s have a different set of allowed value for partial charges than
<code class="docutils literal notranslate"><span class="pre">openff.toolkit.topology.Molecule</span></code> s. In the OpenEye toolkits, partial charges
are stored on individual <code class="docutils literal notranslate"><span class="pre">OEAtom</span></code> s, and their values are initialized to <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.
In the Open Force Field Toolkit, an <code class="docutils literal notranslate"><span class="pre">openff.toolkit.topology.Molecule</span></code>’s
<code class="docutils literal notranslate"><span class="pre">partial_charges</span></code> attribute is initialized to <code class="docutils literal notranslate"><span class="pre">None</span></code> and can be set to a
unit-wrapped numpy array with units of
elementary charge. The Open Force
Field Toolkit considers an <code class="docutils literal notranslate"><span class="pre">OEMol</span></code> where every <code class="docutils literal notranslate"><span class="pre">OEAtom</span></code> has a partial
charge of <code class="docutils literal notranslate"><span class="pre">float('nan')</span></code> to be equivalent to an Open Force Field Toolkit <cite>Molecule</cite>’s
<code class="docutils literal notranslate"><span class="pre">partial_charges</span> <span class="pre">=</span> <span class="pre">None</span></code>.
This assumption is made in both <code class="docutils literal notranslate"><span class="pre">to_openeye</span></code> and <code class="docutils literal notranslate"><span class="pre">from_openeye</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>oemol</strong> – An OpenEye molecule</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if oemol contains undefined stereochemistry.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OpenFF molecule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecule</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a Molecule from an OpenEye OEMol</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openeye</span> <span class="kn">import</span> <span class="n">oechem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit._tests.utils</span> <span class="kn">import</span> <span class="n">get_data_file_path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ifs</span> <span class="o">=</span> <span class="n">oechem</span><span class="o">.</span><span class="n">oemolistream</span><span class="p">(</span><span class="n">get_data_file_path</span><span class="p">(</span><span class="s1">&#39;systems/monomers/ethanol.mol2&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oemols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ifs</span><span class="o">.</span><span class="n">GetOEGraphMols</span><span class="p">())</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">toolkit_wrapper</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_wrapper</span><span class="o">.</span><span class="n">from_openeye</span><span class="p">(</span><span class="n">oemols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_smiles">
<span class="sig-name descname"><span class="pre">from_smiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">smiles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogens_are_explicit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FrozenMolecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.from_smiles" title="Link to this definition"></a></dt>
<dd><p>Create a Molecule from a SMILES string using the OpenEye toolkit.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>smiles</strong> – The SMILES string to turn into a molecule</p></li>
<li><p><strong>hydrogens_are_explicit</strong> – If False, OE will perform hydrogen addition using OEAddExplicitHydrogens</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept SMILES with undefined stereochemistry. If False,
an exception will be raised if a SMILES with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
<li><p><strong>name</strong> – An optional name for the output molecule</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OpenFF style molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecule</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RadicalsNotSupportedError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.generate_conformers">
<span class="sig-name descname"><span class="pre">generate_conformers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rms_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Quantity</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clear_existing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">make_carboxylic_acids_cis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.generate_conformers" title="Link to this definition"></a></dt>
<dd><p>Generate molecule conformers using OpenEye Omega.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to generate conformers for.</p></li>
<li><p><strong>n_conformers</strong> – The maximum number of conformers to generate.</p></li>
<li><p><strong>rms_cutoff</strong> – The minimum RMS value at which two conformers are considered redundant and one is deleted.
If None, the cutoff is set to 1 Angstrom</p></li>
<li><p><strong>clear_existing</strong> – Whether to overwrite existing conformers for the molecule</p></li>
<li><p><strong>make_carboxylic_acids_cis</strong> – Guarantee all conformers have exclusively cis carboxylic acid groups (COOH)
by rotating the proton in any trans carboxylic acids 180 degrees around the C-O bond.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.get_tagged_smarts_connectivity">
<span class="sig-name descname"><span class="pre">get_tagged_smarts_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">smarts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.get_tagged_smarts_connectivity" title="Link to this definition"></a></dt>
<dd><p>Returns a tuple of tuples indicating connectivity between tagged atoms in a SMARTS string. Does not
return bond order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>smarts</strong> – The tagged SMARTS to analyze</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>unique_tags</em> – A sorted tuple of all unique tagged atom map indices.</p></li>
<li><p><em>tagged_atom_connectivity</em> – A tuple of tuples, where each inner tuple is a pair of tagged atoms
(tag_idx_1, tag_idx_2) which are bonded. The inner tuples are ordered
smallest-to-largest, and the tuple of tuples is ordered lexically. The
return value for an improper torsion would be ((1, 2), (2, 3), (2, 4)).</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SMIRKSParsingError</strong> – If OpenEye toolkit was unable to parse the provided smirks/tagged smarts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.is_available">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_available</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.is_available" title="Link to this definition"></a></dt>
<dd><p>Check if the given OpenEye toolkit components are available.</p>
<p>If the OpenEye toolkit is not installed or no license is found
for at least one the required toolkits , <code class="docutils literal notranslate"><span class="pre">False</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if all required OpenEye tools are installed and licensed,
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>all_installed</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_file" title="Link to this definition"></a></dt>
<dd><p>Writes an OpenFF Molecule to a file-like object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to write</p></li>
<li><p><strong>file_path</strong> – The file path to write to.</p></li>
<li><p><strong>file_format</strong> – The format for writing the molecule data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_file_obj">
<span class="sig-name descname"><span class="pre">to_file_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_file_obj" title="Link to this definition"></a></dt>
<dd><p>Writes an OpenFF Molecule to a file-like object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to write</p></li>
<li><p><strong>file_obj</strong> – The file-like object to write to</p></li>
<li><p><strong>file_format</strong> – The format for writing the molecule data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_inchi">
<span class="sig-name descname"><span class="pre">to_inchi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_hydrogens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_inchi" title="Link to this definition"></a></dt>
<dd><p>Create an InChI string for the molecule using the OpenEye OEChem Toolkit.
InChI is a standardised representation that does not capture tautomers
unless specified using the fixed hydrogen layer.</p>
<p>For information on InChi see here <a class="reference external" href="https://iupac.org/who-we-are/divisions/division-details/inchi/">https://iupac.org/who-we-are/divisions/division-details/inchi/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p></li>
<li><p><strong>fixed_hydrogens</strong> – If a fixed hydrogen layer should be added to the InChI, if <cite>True</cite> this
will produce a non standard specific InChI string of the molecule.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>inchi</strong> – The InChI string of the molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>EmptyInChiError</strong> – If OEChem failed to generate an InChI for the molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_inchikey">
<span class="sig-name descname"><span class="pre">to_inchikey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_hydrogens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_inchikey" title="Link to this definition"></a></dt>
<dd><p>Create an InChIKey for the molecule using the OpenEye OEChem Toolkit.
InChIKey is a standardised representation that does not capture tautomers
unless specified using the fixed hydrogen layer.</p>
<p>For information on InChi see here <a class="reference external" href="https://iupac.org/who-we-are/divisions/division-details/inchi/">https://iupac.org/who-we-are/divisions/division-details/inchi/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p></li>
<li><p><strong>fixed_hydrogens</strong> – If a fixed hydrogen layer should be added to the InChI, if <cite>True</cite> this will produce a non standard specific
InChI string of the molecule.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The InChIKey representation of the molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>inchi_key</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>EmptyInChiError</strong> – If OEChem failed to generate an InChI for the molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_iupac">
<span class="sig-name descname"><span class="pre">to_iupac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_iupac" title="Link to this definition"></a></dt>
<dd><p>Generate IUPAC name from Molecule</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>IUPAC name of the molecule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>iupac_name</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">Molecule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit.utils</span> <span class="kn">import</span> <span class="n">get_data_file_path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sdf_filepath</span> <span class="o">=</span> <span class="n">get_data_file_path</span><span class="p">(</span><span class="s1">&#39;molecules/ethanol.sdf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">molecule</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">sdf_filepath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toolkit</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iupac_name</span> <span class="o">=</span> <span class="n">toolkit</span><span class="o">.</span><span class="n">to_iupac</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_openeye">
<span class="sig-name descname"><span class="pre">to_openeye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FrozenMolecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aromaticity_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OEAroModel_MDL'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_openeye" title="Link to this definition"></a></dt>
<dd><p>Create an OpenEye molecule using the specified aromaticity model</p>
<p><code class="docutils literal notranslate"><span class="pre">OEAtom</span></code> s have a different set of allowed value for partial
charges than <code class="docutils literal notranslate"><span class="pre">openff.toolkit.topology.Molecule</span></code>s. In the
OpenEye toolkits, partial charges are stored on individual
<code class="docutils literal notranslate"><span class="pre">OEAtom</span></code>s, and their values are initialized to <code class="docutils literal notranslate"><span class="pre">0.0</span></code>. In
the Open Force Field Toolkit, an``openff.toolkit.topology.Molecule``’s
<code class="docutils literal notranslate"><span class="pre">partial_charges</span></code> attribute is initialized to <code class="docutils literal notranslate"><span class="pre">None</span></code> and can
be set to a unit-wrapped numpy array with
units of elementary charge. The Open Force Field Toolkit
considers an <code class="docutils literal notranslate"><span class="pre">OEMol</span></code> where every <code class="docutils literal notranslate"><span class="pre">OEAtom</span></code> has a partial
charge of <code class="docutils literal notranslate"><span class="pre">float('nan')</span></code> to be equivalent to an Open Force
Field Toolkit <code class="docutils literal notranslate"><span class="pre">Molecule</span></code>’s <code class="docutils literal notranslate"><span class="pre">partial_charges</span> <span class="pre">=</span> <span class="pre">None</span></code>. This
assumption is made in both <code class="docutils literal notranslate"><span class="pre">to_openeye</span></code> and <code class="docutils literal notranslate"><span class="pre">from_openeye</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert to an OEMol</p></li>
<li><p><strong>aromaticity_model</strong> – The aromaticity model to use</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OpenEye molecule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>oemol</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create an OpenEye molecule from a Molecule</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">Molecule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">toolkit_wrapper</span> <span class="o">=</span> <span class="n">OpenEyeToolkitWrapper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">molecule</span> <span class="o">=</span> <span class="n">Molecule</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span><span class="s1">&#39;CC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">oemol</span> <span class="o">=</span> <span class="n">toolkit_wrapper</span><span class="o">.</span><span class="n">to_openeye</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_smiles">
<span class="sig-name descname"><span class="pre">to_smiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isomeric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explicit_hydrogens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapped</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.OpenEyeToolkitWrapper.to_smiles" title="Link to this definition"></a></dt>
<dd><p>Uses the OpenEye toolkit to convert a Molecule into a SMILES string.
A partially mapped smiles can also be generated for atoms of interest by supplying an <cite>atom_map</cite> to the
properties dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p></li>
<li><p><strong>isomeric</strong> – return an isomeric smiles</p></li>
<li><p><strong>explicit_hydrogens</strong> – return a smiles string containing all hydrogens explicitly</p></li>
<li><p><strong>mapped</strong> – return a explicit hydrogen mapped smiles, the atoms to be mapped can be controlled by supplying an
atom map into the properties dictionary. If no mapping is passed all atoms will be mapped in order, else
an atom map dictionary from the current atom index to the map id should be supplied with no duplicates.
The map ids (values) should start from 0 or 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The SMILES of the input molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>smiles</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.PDI">
<span class="sig-name descname"><span class="pre">PDI</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.PDI" title="Link to this definition"></a></dt>
<dd><p>Calculates the Polydispersity Index (PDI), number-average molecular weight (Mn), and weight-average molecular weight (Mw) of a list of chains.</p>
<p>This function takes a list of molecular chains and calculates the PDI, which is the ratio of Mw to Mn. It also calculates Mn, which is the sum of the molecular weights of the chains divided by the number of chains, and Mw, which is the sum of the product of the weight fraction and molecular weight of each chain.</p>
<p>Parameters:
chains (list): A list of molecular chains. Each chain is represented as an RDkit molecule object.</p>
<p>Returns:
tuple: A tuple containing the PDI (float), Mn (float), and Mw (float).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RDKitToolkitWrapper</span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ToolkitWrapper</span></code></p>
<p>RDKit toolkit wrapper</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.SUPPORTED_CHARGE_METHODS">
<span class="sig-name descname"><span class="pre">SUPPORTED_CHARGE_METHODS</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'gasteiger',</span> <span class="pre">'mmff94'}</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.SUPPORTED_CHARGE_METHODS" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.apply_elf_conformer_selection">
<span class="sig-name descname"><span class="pre">apply_elf_conformer_selection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule:</span> <span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rms_tolerance:</span> <span class="pre">~pint.Quantity</span> <span class="pre">=</span> <span class="pre">&lt;Quantity(0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'angstrom')&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.apply_elf_conformer_selection" title="Link to this definition"></a></dt>
<dd><p>Applies the <a class="reference external" href="https://docs.eyesopen.com/toolkits/python/quacpactk/molchargetheory.html#elf-conformer-selection">ELF method</a>
to select a set of diverse conformers which have minimal electrostatically
strongly interacting functional groups from a molecules conformers.</p>
<p>The diverse conformer selection is performed by the <code class="docutils literal notranslate"><span class="pre">_elf_select_diverse_conformers</span></code>
function, which attempts to greedily select conformers which are most distinct
according to their RMS.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>Although this function is inspired by the OpenEye ELF10 method, this
implementation may yield slightly different conformers due to potential
differences in this and the OE closed source implementation.</p></li>
</ul>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input molecule should have a large set of conformers already
generated to select the ELF10 conformers from.</p></li>
<li><p>The selected conformers will be retained in the <cite>molecule.conformers</cite> list
while unselected conformers will be discarded.</p></li>
<li><p>Only heavy atoms are included when using the RMS to select diverse conformers.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RDKitToolkitWrapper._elf_select_diverse_conformers</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule which contains the set of conformers to select from.</p></li>
<li><p><strong>percentage</strong> – The percentage of conformers with the lowest electrostatic interaction
energies to greedily select from.</p></li>
<li><p><strong>limit</strong> – The maximum number of conformers to select.</p></li>
<li><p><strong>rms_tolerance</strong> – Conformers whose RMS is within this amount will be treated as identical and
the duplicate discarded.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.assign_partial_charges">
<span class="sig-name descname"><span class="pre">assign_partial_charges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partial_charge_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Quantity</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_n_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_partial_charges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.assign_partial_charges" title="Link to this definition"></a></dt>
<dd><p>Compute partial charges with RDKit, and assign
the new values to the partial_charges attribute.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – Molecule for which partial charges are to be computed</p></li>
<li><p><strong>partial_charge_method</strong> – The charge model to use. One of [‘mmff94’, ‘gasteiger’]. If None, ‘mmff94’ will be used.</p>
<ul>
<li><dl class="simple">
<dt>‘mmff94’: Applies partial charges using the Merck Molecular Force Field</dt><dd><p>(MMFF). This method does not make use of conformers, and hence
<code class="docutils literal notranslate"><span class="pre">use_conformers</span></code> and <code class="docutils literal notranslate"><span class="pre">strict_n_conformers</span></code> will not impact
the partial charges produced.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p><strong>use_conformers</strong> – shape (n_atoms, 3) and dimension of distance. Optional, default = None
Coordinates to use for partial charge calculation. If None, an appropriate number of
conformers will be generated.</p></li>
<li><p><strong>strict_n_conformers</strong> – Whether to raise an exception if an invalid number of conformers is provided for
the given charge method.
If this is False and an invalid number of conformers is found, a warning will be raised.</p></li>
<li><p><strong>normalize_partial_charges</strong> – Whether to offset partial charges so that they sum to the total formal charge of the molecule.
This is used to prevent accumulation of rounding errors when the partial charge generation method has
low precision.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ChargeMethodUnavailableError if the requested charge method can not be handled by this toolkit</strong> – </p></li>
<li><p><strong>ChargeCalculationError if the charge method is supported by this toolkit</strong><strong>, </strong><strong>but fails</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.atom_is_in_ring">
<span class="sig-name descname"><span class="pre">atom_is_in_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atom</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.atom_is_in_ring" title="Link to this definition"></a></dt>
<dd><p>Return whether or not an atom is in a ring.</p>
<p>It is assumed that this atom is in molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atom</strong> – The molecule containing the atom of interest</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether or not the atom is in a ring.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>is_in_ring</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotAttachedToMoleculeError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.bond_is_in_ring">
<span class="sig-name descname"><span class="pre">bond_is_in_ring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bond</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Bond</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.bond_is_in_ring" title="Link to this definition"></a></dt>
<dd><p>Return whether or not a bond is in a ring.</p>
<p>It is assumed that this atom is in molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bond</strong> – The molecule containing the atom of interest</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Whether or not the bond of index <cite>bond_index</cite> is in a ring</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>is_in_ring</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotAttachedToMoleculeError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.canonical_order_atoms">
<span class="sig-name descname"><span class="pre">canonical_order_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Molecule</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.canonical_order_atoms" title="Link to this definition"></a></dt>
<dd><p>Canonical order the atoms in the molecule using the RDKit.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>molecule</strong> –    The input molecule</p>
<p>Returns</p>
</li>
<li><p><strong>——-</strong></p></li>
<li><p><strong>molecule</strong> – The input molecule, with canonically-indexed atoms and bonds.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.enumerate_stereoisomers">
<span class="sig-name descname"><span class="pre">enumerate_stereoisomers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undefined_only</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_isomers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rationalise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Molecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.enumerate_stereoisomers" title="Link to this definition"></a></dt>
<dd><p>Enumerate the stereocenters and bonds of the current molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule whose state we should enumerate</p></li>
<li><p><strong>undefined_only</strong> – If we should enumerate all stereocenters and bonds or only those with undefined stereochemistry</p></li>
<li><p><strong>max_isomers</strong> – The maximum amount of molecules that should be returned</p></li>
<li><p><strong>rationalise</strong> – If we should try to build and rationalise the molecule to ensure it can exist</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of openff.toolkit.topology.Molecule instances</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.enumerate_tautomers">
<span class="sig-name descname"><span class="pre">enumerate_tautomers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Molecule</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.enumerate_tautomers" title="Link to this definition"></a></dt>
<dd><p>Enumerate the possible tautomers of the current molecule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule whose state we should enumerate</p></li>
<li><p><strong>max_states</strong> – The maximum amount of molecules that should be returned</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of openff.toolkit.topology.Molecule instances not including the input molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.find_smarts_matches">
<span class="sig-name descname"><span class="pre">find_smarts_matches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smarts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aromaticity_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OEAroModel_MDL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.find_smarts_matches" title="Link to this definition"></a></dt>
<dd><p>Find all SMARTS matches for the specified molecule, using the specified aromaticity model.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule for which all specified SMARTS matches are to be located</p></li>
<li><p><strong>smarts</strong> – SMARTS string with optional SMIRKS-style atom tagging</p></li>
<li><p><strong>aromaticity_model</strong> – Molecule is prepared with this aromaticity model prior to querying.</p></li>
<li><p><strong>unique</strong> – If True, only return unique matches. If False, return all matches.</p></li>
<li><p><strong>.. note :: Currently, the only supported ``aromaticity_model`` is ``OEAroModel_MDL``</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_file">
<span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_file" title="Link to this definition"></a></dt>
<dd><p>Create an openff.toolkit.topology.Molecule from a file using this toolkit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – The file to read the molecule from</p></li>
<li><p><strong>file_format</strong> – Format specifier, usually file suffix (eg. ‘MOL2’, ‘SMI’)
Note that not all toolkits support all formats. Check
ToolkitWrapper.toolkit_file_read_formats for details.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if RDMol contains undefined stereochemistry.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of Molecule objects is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_file_obj">
<span class="sig-name descname"><span class="pre">from_file_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_file_obj" title="Link to this definition"></a></dt>
<dd><p>Return an openff.toolkit.topology.Molecule from a file-like object using this toolkit.</p>
<p>A file-like object is an object with a “.read()” method.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_obj</strong> – The file-like object to read the molecule from</p></li>
<li><p><strong>file_format</strong> – Format specifier, usually file suffix (eg. ‘MOL2’, ‘SMI’)
Note that not all toolkits support all formats. Check
ToolkitWrapper.toolkit_file_read_formats for details.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if RDMol contains undefined stereochemistry.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of Molecule objects is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecules</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_inchi">
<span class="sig-name descname"><span class="pre">from_inchi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inchi</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_inchi" title="Link to this definition"></a></dt>
<dd><p>Construct a Molecule from a InChI representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inchi</strong> – The InChI representation of the molecule.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept InChI with undefined stereochemistry. If False,
an exception will be raised if a InChI with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_object">
<span class="sig-name descname"><span class="pre">from_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_object" title="Link to this definition"></a></dt>
<dd><p>If given an rdchem.Mol (or rdchem.Mol-derived object), this function will load it into an
openff.toolkit.topology.molecule. Otherwise, it will return False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – An object to be type-checked and converted into a Molecule, if possible.</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept molecules with undefined stereocenters. If False,
an exception will be raised if a molecule with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An openff.toolkit.topology.molecule Molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Molecule or False</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – If the object could not be converted into a Molecule.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_pdb_and_smiles">
<span class="sig-name descname"><span class="pre">from_pdb_and_smiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smiles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_pdb_and_smiles" title="Link to this definition"></a></dt>
<dd><p>Create a Molecule from a pdb file and a SMILES string using RDKit.</p>
<p>Requires RDKit to be installed.</p>
<p>The molecule is created and sanitised based on the SMILES string, we then find a mapping
between this molecule and one from the PDB based only on atomic number and connections.
The SMILES molecule is then reindexed to match the PDB, the conformer is attached, and the
molecule returned.</p>
<p>Note that any stereochemistry in the molecule is set by the SMILES, and not the coordinates
of the PDB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_path</strong> – PDB file path</p></li>
<li><p><strong>smiles</strong> – a valid smiles string for the pdb, used for stereochemistry, formal charges, and bond order</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if SMILES contains undefined stereochemistry.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
<li><p><strong>name</strong> – An optional name for the output molecule</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OFFMol instance with ordering the same as used in the PDB file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecule</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>InvalidConformerError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_rdkit">
<span class="sig-name descname"><span class="pre">from_rdkit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rdmol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogens_are_explicit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_rdkit" title="Link to this definition"></a></dt>
<dd><p>Create a Molecule from an RDKit molecule.</p>
<p>Requires the RDKit to be installed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rdmol</strong> – An RDKit molecule</p></li>
<li><p><strong>allow_undefined_stereo</strong> – If false, raises an exception if rdmol contains undefined stereochemistry.</p></li>
<li><p><strong>hydrogens_are_explicit</strong> – If False, RDKit will perform hydrogen addition using Chem.AddHs</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OpenFF molecule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecule</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a molecule from an RDKit molecule</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openff.toolkit._tests.utils</span> <span class="kn">import</span> <span class="n">get_data_file_path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromMolFile</span><span class="p">(</span><span class="n">get_data_file_path</span><span class="p">(</span><span class="s1">&#39;systems/monomers/ethanol.sdf&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">toolkit_wrapper</span> <span class="o">=</span> <span class="n">RDKitToolkitWrapper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">molecule</span> <span class="o">=</span> <span class="n">toolkit_wrapper</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.from_smiles">
<span class="sig-name descname"><span class="pre">from_smiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">smiles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hydrogens_are_explicit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_undefined_stereo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.from_smiles" title="Link to this definition"></a></dt>
<dd><p>Create a Molecule from a SMILES string using the RDKit toolkit.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>smiles</strong> – The SMILES string to turn into a molecule</p></li>
<li><p><strong>hydrogens_are_explicit</strong> – If False, RDKit will perform hydrogen addition using Chem.AddHs</p></li>
<li><p><strong>allow_undefined_stereo</strong> – Whether to accept SMILES with undefined stereochemistry. If False,
an exception will be raised if a SMILES with undefined stereochemistry
is passed into this function.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
<li><p><strong>name</strong> – An optional name to pass to the _cls constructor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OpenFF style molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>molecule</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RadicalsNotSupportedError</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.generate_conformers">
<span class="sig-name descname"><span class="pre">generate_conformers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_conformers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rms_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Quantity</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clear_existing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">make_carboxylic_acids_cis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.generate_conformers" title="Link to this definition"></a></dt>
<dd><p>Generate molecule conformers using RDKit.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to generate conformers for.</p></li>
<li><p><strong>n_conformers</strong> – Maximum number of conformers to generate.</p></li>
<li><p><strong>rms_cutoff</strong> – The minimum RMS value at which two conformers are considered redundant and one is deleted.
If None, the cutoff is set to 1 Angstrom</p></li>
<li><p><strong>clear_existing</strong> – Whether to overwrite existing conformers for the molecule.</p></li>
<li><p><strong>_cls</strong> – Molecule constructor</p></li>
<li><p><strong>make_carboxylic_acids_cis</strong> – Guarantee all conformers have exclusively cis carboxylic acid groups (COOH)
by rotating the proton in any trans carboxylic acids 180 degrees around the C-O bond.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.get_tagged_smarts_connectivity">
<span class="sig-name descname"><span class="pre">get_tagged_smarts_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">smarts</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.get_tagged_smarts_connectivity" title="Link to this definition"></a></dt>
<dd><p>Returns a tuple of tuples indicating connectivity between tagged atoms in a SMARTS string. Does not
return bond order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>smarts</strong> – The tagged SMARTS to analyze</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><em>unique_tags</em> – A sorted tuple of all unique tagged atom map indices.</p></li>
<li><p><em>tagged_atom_connectivity</em> –</p>
<dl class="simple">
<dt>A tuple of tuples, where each inner tuple is a pair of tagged atoms (tag_idx_1, tag_idx_2)</dt><dd><p>which are bonded. The inner tuples are ordered smallest-to-largest, and the tuple of
tuples is ordered lexically. So the return value for an improper torsion would be
((1, 2), (2, 3), (2, 4)).</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>SMIRKSParsingError</strong> – If RDKit was unable to parse the provided smirks/tagged smarts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.is_available">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_available</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.is_available" title="Link to this definition"></a></dt>
<dd><p>Check whether the RDKit toolkit can be imported</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if RDKit is installed, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>is_installed</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_file" title="Link to this definition"></a></dt>
<dd><p>Writes an OpenFF Molecule to a file-like object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to write</p></li>
<li><p><strong>file_path</strong> – The file path to write to</p></li>
<li><p><strong>file_format</strong> – The format for writing the molecule data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.to_file_obj">
<span class="sig-name descname"><span class="pre">to_file_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_format</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_file_obj" title="Link to this definition"></a></dt>
<dd><p>Writes an OpenFF Molecule to a file-like object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to write</p></li>
<li><p><strong>file_obj</strong> – The file-like object to write to</p></li>
<li><p><strong>file_format</strong> – The format for writing the molecule data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.to_inchi">
<span class="sig-name descname"><span class="pre">to_inchi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_hydrogens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_inchi" title="Link to this definition"></a></dt>
<dd><p>Create an InChI string for the molecule using the RDKit Toolkit.
InChI is a standardised representation that does not capture tautomers
unless specified using the fixed hydrogen layer.</p>
<p>For information on InChi see here <a class="reference external" href="https://iupac.org/who-we-are/divisions/division-details/inchi/">https://iupac.org/who-we-are/divisions/division-details/inchi/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p></li>
<li><p><strong>fixed_hydrogens</strong> – If a fixed hydrogen layer should be added to the InChI, if <cite>True</cite> this will produce a
non standard specific InChI string of the molecule.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The InChI string of the molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>inchi</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>EmptyInChiError</strong> – If RDKit failed to generate an InChI for the molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.to_inchikey">
<span class="sig-name descname"><span class="pre">to_inchikey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_hydrogens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_inchikey" title="Link to this definition"></a></dt>
<dd><p>Create an InChIKey for the molecule using the RDKit Toolkit.
InChIKey is a standardised representation that does not capture tautomers
unless specified using the fixed hydrogen layer.</p>
<p>For information on InChi see here <a class="reference external" href="https://iupac.org/who-we-are/divisions/division-details/inchi/">https://iupac.org/who-we-are/divisions/division-details/inchi/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p></li>
<li><p><strong>fixed_hydrogens</strong> – If a fixed hydrogen layer should be added to the InChI, if <cite>True</cite> this will
produce a non standard specific InChI string of the molecule.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The InChIKey representation of the molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>inchi_key</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>EmptyInChiError</strong> – If RDKit failed to generate an InChI for the molecule</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.to_rdkit">
<span class="sig-name descname"><span class="pre">to_rdkit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aromaticity_model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'OEAroModel_MDL'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_rdkit" title="Link to this definition"></a></dt>
<dd><p>Create an RDKit molecule
Requires the RDKit to be installed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is experimental and subject to change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>aromaticity_model</strong> – The aromaticity model to use. Only OEAroModel_MDL is supported.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An RDKit molecule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>rdmol</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Convert a molecule to RDKit
&gt;&gt;&gt; from openff.toolkit import Molecule
&gt;&gt;&gt; ethanol = Molecule.from_smiles(‘CCO’)
&gt;&gt;&gt; rdmol = ethanol.to_rdkit()</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.to_smiles">
<span class="sig-name descname"><span class="pre">to_smiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isomeric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">explicit_hydrogens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapped</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.to_smiles" title="Link to this definition"></a></dt>
<dd><p>Uses the RDKit toolkit to convert a Molecule into a SMILES string.
A partially mapped smiles can also be generated for atoms of interest by supplying
an <cite>atom_map</cite> to the properties dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecule</strong> – The molecule to convert into a SMILES.</p></li>
<li><p><strong>isomeric</strong> – return an isomeric smiles</p></li>
<li><p><strong>explicit_hydrogens</strong> – return a smiles string containing all hydrogens explicitly</p></li>
<li><p><strong>mapped</strong> – return a explicit hydrogen mapped smiles, the atoms to be mapped can be controlled by
supplying an atom map into the properties dictionary. If no mapping is passed all
atoms will be mapped in order, else an atom map dictionary from the current atom
index to the map id should be supplied with no duplicates. The map ids (values) should
start from 0 or 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The SMILES of the input molecule.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>smiles</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.RDKitToolkitWrapper.toolkit_file_write_formats">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">toolkit_file_write_formats</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#swiftpol.build.polymer_system.RDKitToolkitWrapper.toolkit_file_write_formats" title="Link to this definition"></a></dt>
<dd><p>List of file formats that this toolkit can write.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.UNIT_CUBE">
<span class="sig-name descname"><span class="pre">UNIT_CUBE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">array([[1,</span> <span class="pre">0,</span> <span class="pre">0],</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0],</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]])</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.UNIT_CUBE" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.blockiness_gen">
<span class="sig-name descname"><span class="pre">blockiness_gen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.blockiness_gen" title="Link to this definition"></a></dt>
<dd><p>Calculate the blockiness and average block length of a co-polymer sequence.</p>
<p>This function calculates the blockiness of a co-polymer sequence by counting the occurrences of ‘GG’ and ‘GL’ or ‘LG’ in the sequence.
It also calculates the average block length of ‘G’ and ‘L’ in the sequence.</p>
<p>Parameters:
sequence (str): A string representing the co-polymer sequence. ‘G’ represents one type of monomer and ‘L’ represents another type.</p>
<p>Returns:
blockiness (float): The blockiness of the co-polymer sequence. Calculated as the ratio of ‘GG’ to ‘GL’ or ‘LG’.
block_length_G (float): The average block length of ‘G’ in the sequence.
block_length_L (float): The average block length of ‘L’ in the sequence.</p>
<p>If the sequence does not contain both ‘G’ and ‘L’, the function returns a string indicating that the molecule is not a co-polymer.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.build_bulk">
<span class="sig-name descname"><span class="pre">build_bulk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resid_monomer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt_concentration=&lt;Quantity(0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'mole</span> <span class="pre">/</span> <span class="pre">liter')&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#polymer_system.build_bulk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.polymer_system.build_bulk" title="Link to this definition"></a></dt>
<dd><p>Build a bulk system using packmol functions.</p>
<p>This method constructs a bulk system by packing the polymer chains into a box using the packmol algorithm.
It calculates the topology from the polymer chains, determines the maximum distance between points in the
solute to set the box size, and then uses the <cite>pack_box</cite> function to create the bulk system.</p>
<p>Parameters:
resid_monomer (str): The residual monomer to be used in the system.
salt_concentration (Quantity, optional): The concentration of salt to be added to the system.</p>
<blockquote>
<div><p>Defaults to 0 mole/liter.</p>
</div></blockquote>
<p>Returns:
bulk_system: The bulk system generated by packmol.</p>
<p>Raises:
ImportError: If the OpenFF Interchange toolkit is not available.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.build_polymer">
<span class="sig-name descname"><span class="pre">build_polymer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monomer_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reaction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">terminal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'hydroxyl'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.build_polymer" title="Link to this definition"></a></dt>
<dd><p>Constructs a polymer from a given sequence of monomers.</p>
<p>Parameters:
sequence (str): A string representing the sequence of monomers (e.g., ‘ABAB’).
monomer_list (list): A list of SMILES strings representing the monomers.
reaction (rdkit.Chem.rdChemReactions.ChemicalReaction): An RDKit reaction object used to link monomers.
terminal (str, optional): The terminal group to be added to the polymer. Options are ‘hydroxyl’, ‘carboxyl’, or ‘ester’. Default is ‘hydroxyl’.</p>
<p>Returns:
rdkit.Chem.rdchem.Mol: The constructed polymer as an RDKit molecule object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.calculate_box_components">
<span class="sig-name descname"><span class="pre">calculate_box_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monomers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt_concentration=&lt;Quantity(0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">'mole</span> <span class="pre">/</span> <span class="pre">liter')&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_monomer=0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.calculate_box_components" title="Link to this definition"></a></dt>
<dd><p>ADAPTED FROM OPENFF TOOLKIT PACKMOL WRAPPER SOLVATE_TOPOLOGY FUNCTION
Calculates the components required to construct a simulation box for a given set of molecular chains.
Considers the salt concentration and residual monomer concentration to determine the quantity of each molecule type required.</p>
<p>Parameters:
chains (list): A list of molecular chains to be included in the simulation box.
sequence (str): A string representing the sequence of the molecular chains. ‘G’ and ‘L’ represent different types of monomers.
salt_concentration (float, optional): The desired salt concentration in the simulation box. Defaults to 0.1 M.
residual_monomer (float, optional): The desired residual monomer concentration in the simulation box. Defaults to 0.05.</p>
<p>Returns:
tuple: A tuple containing the following elements:</p>
<blockquote>
<div><ul class="simple">
<li><p>molecules (list): A list of molecules to be included in the simulation box.</p></li>
<li><p>number_of_copies (list): A list indicating the quantity of each molecule to be included in the simulation box.</p></li>
<li><p>topology (openff.toolkit.topology.Topology): The topology of the simulation box.</p></li>
<li><p>box_vectors (numpy.ndarray): The vectors defining the dimensions of the simulation box.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.charge_system">
<span class="sig-name descname"><span class="pre">charge_system</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#polymer_system.charge_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.polymer_system.charge_system" title="Link to this definition"></a></dt>
<dd><p>Assign partial charges to each polymer chain in the system.</p>
<p>This method uses the OpenFF NAGL toolkit to assign partial charges to each polymer chain in the system.
It initializes a NAGLToolkitWrapper and assigns partial charges using the “openff-gnn-am1bcc-0.1.0-rc.2.pt” model.</p>
<p>The method iterates over each chain in the <cite>self.chains</cite> list and assigns partial charges to the chain.</p>
<p>Raises:
ImportError: If the NAGL toolkit is not available.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.generate_conformers">
<span class="sig-name descname"><span class="pre">generate_conformers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#polymer_system.generate_conformers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.polymer_system.generate_conformers" title="Link to this definition"></a></dt>
<dd><p>Generate conformers for each polymer chain in the system.</p>
<p>This method uses the OpenFF toolkit to generate conformers for each polymer chain in the system.
It first checks if the OpenEye toolkit is licensed and available. If it is, it uses the OpenEyeToolkitWrapper
to generate conformers. Otherwise, it falls back to using the RDKitToolkitWrapper. Each chain is processed
to generate a single conformer, and unique atom names are assigned to each chain.</p>
<p>Raises:
ImportError: If neither RDKit nor OpenEye toolkits are available.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#swiftpol.build.polymer_system.mean" title="Link to this definition"></a></dt>
<dd><p>Return the sample arithmetic mean of data.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2.8</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span> <span class="k">as</span> <span class="n">F</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">([</span><span class="n">F</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="go">Fraction(13, 21)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span> <span class="k">as</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean</span><span class="p">([</span><span class="n">D</span><span class="p">(</span><span class="s2">&quot;0.5&quot;</span><span class="p">),</span> <span class="n">D</span><span class="p">(</span><span class="s2">&quot;0.75&quot;</span><span class="p">),</span> <span class="n">D</span><span class="p">(</span><span class="s2">&quot;0.625&quot;</span><span class="p">),</span> <span class="n">D</span><span class="p">(</span><span class="s2">&quot;0.375&quot;</span><span class="p">)])</span>
<span class="go">Decimal(&#39;0.5625&#39;)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">data</span></code> is empty, StatisticsError will be raised.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.np">
<span class="sig-name descname"><span class="pre">np</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;module</span> <span class="pre">'numpy'</span> <span class="pre">from</span> <span class="pre">'/opt/anaconda3/envs/polymer/lib/python3.11/site-packages/numpy/__init__.py'&gt;</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.np" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.oechem">
<span class="sig-name descname"><span class="pre">oechem</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;module</span> <span class="pre">'oechem'</span> <span class="pre">from</span> <span class="pre">'/opt/anaconda3/envs/polymer/lib/python3.11/site-packages/openeye/oechem.py'&gt;</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.oechem" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.pack_box">
<span class="sig-name descname"><span class="pre">pack_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">number_of_copies:</span> <span class="pre">list[int],</span> <span class="pre">solute:</span> <span class="pre">~openff.toolkit.topology.topology.Topology</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">tolerance:</span> <span class="pre">~pint.Quantity</span> <span class="pre">=</span> <span class="pre">&lt;Quantity(2.0,</span> <span class="pre">'angstrom')&gt;,</span> <span class="pre">box_vectors:</span> <span class="pre">~pint.Quantity</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">target_density:</span> <span class="pre">~pint.Quantity</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">box_shape:</span> <span class="pre">~numpy._typing._array_like._SupportsArray[~numpy.dtype[~typing.Any]]</span> <span class="pre">|</span> <span class="pre">~numpy._typing._nested_sequence._NestedSequence[~numpy._typing._array_like._SupportsArray[~numpy.dtype[~typing.Any]]]</span> <span class="pre">|</span> <span class="pre">bool</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span> <span class="pre">|</span> <span class="pre">complex</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">bytes</span> <span class="pre">|</span> <span class="pre">~numpy._typing._nested_sequence._NestedSequence[bool</span> <span class="pre">|</span> <span class="pre">int</span> <span class="pre">|</span> <span class="pre">float</span> <span class="pre">|</span> <span class="pre">complex</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">bytes]</span> <span class="pre">=</span> <span class="pre">array([[1.</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">0.</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">0.</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">],</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">[0.</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">1.</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">0.</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">],</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">[0.5</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">0.5</span>&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">,</span> <span class="pre">0.70710678]]),</span> <span class="pre">center_solute:</span> <span class="pre">bool</span> <span class="pre">|</span> <span class="pre">~typing.Literal['BOX_VECS',</span> <span class="pre">'ORIGIN',</span> <span class="pre">'BRICK']</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">working_directory:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">retain_working_files:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Topology</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.pack_box" title="Link to this definition"></a></dt>
<dd><p>Run packmol to generate a box containing a mixture of molecules.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>molecules</strong> (<em>list of openff.toolkit.Molecule</em>) – The molecules in the system.</p></li>
<li><p><strong>number_of_copies</strong> (<em>list of int</em>) – A list of the number of copies of each molecule type, of length
equal to the length of <code class="docutils literal notranslate"><span class="pre">molecules</span></code>.</p></li>
<li><p><strong>solute</strong> (<em>Topology, optional</em>) – An OpenFF <code class="xref py py-class docutils literal notranslate"><span class="pre">Topology</span></code> to
include in the box. If <code class="docutils literal notranslate"><span class="pre">box_vectors</span></code> and <code class="docutils literal notranslate"><span class="pre">target_density</span></code> are not
specified, box vectors can be taken from <code class="docutils literal notranslate"><span class="pre">solute.box_vectors</span></code>.</p></li>
<li><p><strong>tolerance</strong> (<em>openff.units.Quantity</em>) – The minimum spacing between molecules during packing in units of
distance. The default is large so that added waters do not disrupt the
structure of proteins; when constructing a mixture of small molecules,
values as small as 0.5 Å will converge faster and can still produce
stable simulations after energy minimisation.</p></li>
<li><p><strong>box_vectors</strong> (<em>openff.units.Quantity, optional</em>) – The box vectors to fill in units of distance. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
<code class="docutils literal notranslate"><span class="pre">target_density</span></code> must be provided. Array with shape (3,3). Box vectors
must be provided in <a class="reference external" href="http://docs.openmm.org/latest/userguide/theory/05_other_features.html#periodic-boundary-conditions">OpenMM reduced form</a>.</p></li>
<li><p><strong>target_density</strong> (<em>openff.units.Quantity, optional</em>) – Target mass density for final system with units compatible with g / mL.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">box_size</span></code> must be provided.</p></li>
<li><p><strong>box_shape</strong> (<em>Arraylike, optional</em>) – The shape of the simulation box, used in conjunction with
the <code class="docutils literal notranslate"><span class="pre">target_density</span></code> parameter. Should be a dimensionless array with
shape (3,3) for a triclinic box or (3,) for a rectangular box. Shape
vectors must be provided in <a class="reference external" href="http://docs.openmm.org/latest/userguide/theory/05_other_features.html#periodic-boundary-conditions">OpenMM reduced form</a>.</p></li>
<li><p><strong>center_solute</strong> – How to center <code class="docutils literal notranslate"><span class="pre">solute</span></code> in the simulation box. If <code class="docutils literal notranslate"><span class="pre">True</span></code>
or <code class="docutils literal notranslate"><span class="pre">&quot;box_vecs&quot;</span></code>, the solute’s center of geometry will be placed at
the center of the box’s parallelopiped representation. If <code class="docutils literal notranslate"><span class="pre">&quot;origin&quot;</span></code>,
the solute will centered at the origin. If <code class="docutils literal notranslate"><span class="pre">&quot;brick&quot;</span></code>, the solute will
be centered in the box’s rectangular brick representation. If
<code class="docutils literal notranslate"><span class="pre">False</span></code> (the default), the solute will not be moved.</p></li>
<li><p><strong>working_directory</strong> (<em>str, optional</em>) – The directory in which to generate the temporary working files. If
<code class="docutils literal notranslate"><span class="pre">None</span></code>, a temporary one will be created.</p></li>
<li><p><strong>retain_working_files</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> all of the working files, such as individual molecule
coordinate files, will be retained.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An OpenFF <code class="docutils literal notranslate"><span class="pre">Topology</span></code> with the solvated system.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Topology</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>PACKMOLRuntimeError</strong> – When packmol fails to execute / converge.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Returned topologies may have larger box vectors than what would be defined
by the target density.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">value</span></span></span><a class="headerlink" href="#swiftpol.build.polymer_system.reduce" title="Link to this definition"></a></dt>
<dd><p>Apply a function of two arguments cumulatively to the items of a sequence
or iterable, from left to right, so as to reduce the iterable to a single
value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
of the iterable in the calculation, and serves as a default when the
iterable is empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.solvate_system">
<span class="sig-name descname"><span class="pre">solvate_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resid_monomer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">salt_concentration</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/build.html#polymer_system.solvate_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.build.polymer_system.solvate_system" title="Link to this definition"></a></dt>
<dd><p>Builds solvated system using packmol functions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="swiftpol.build.polymer_system.unit">
<span class="sig-name descname"><span class="pre">unit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;openff.units.units.UnitRegistry</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#swiftpol.build.polymer_system.unit" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="swiftpol-parameterize">
<h1>swiftpol.parameterize<a class="headerlink" href="#swiftpol-parameterize" title="Link to this heading"></a></h1>
<dl class="py function" id="module-swiftpol.parameterize">
<dt class="sig sig-object py" id="swiftpol.parameterize.charge_polymer">
<span class="sig-prename descclassname"><span class="pre">swiftpol.parameterize.</span></span><span class="sig-name descname"><span class="pre">charge_polymer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polymer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charge_scheme</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/parameterize.html#charge_polymer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.parameterize.charge_polymer" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="swiftpol.parameterize.forcefield_with_charge_handler">
<span class="sig-prename descclassname"><span class="pre">swiftpol.parameterize.</span></span><span class="sig-name descname"><span class="pre">forcefield_with_charge_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charge_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forcefield</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'openff-2.2.0.offxml'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensemble</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/swiftpol/parameterize.html#forcefield_with_charge_handler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#swiftpol.parameterize.forcefield_with_charge_handler" title="Link to this definition"></a></dt>
<dd><p>Create a forcefield with a charge handler for a given molecule and charge method. The function can handle both individual molecules and ensembles of molecules.</p>
<p>Parameters:
molecule: An RDKit molecule object or a list of RDKit molecule objects for which the forcefield is to be created.
charge_method: A string that specifies the charge method to be used for the molecule.
forcefield: A string that specifies the forcefield to be used. Default is “openff-2.2.0.offxml”.
ensemble: A boolean that specifies whether the input molecule is an ensemble of molecules. Default is False.</p>
<p>Returns:
An OpenFF ForceField object with the specified molecule’s charges added to the LibraryCharges parameter.</p>
<p>Raises:
Exception: If the charge method is not supported.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="getting_started.html" class="btn btn-neutral float-left" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hannah Turney. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.1.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>