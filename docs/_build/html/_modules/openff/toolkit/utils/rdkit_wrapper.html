

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>openff.toolkit.utils.rdkit_wrapper &mdash; swiftpol  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            swiftpol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html#getting-started-with-swiftpol">Getting Started with Swiftpol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#module-swiftpol.build">swiftpol.build</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#swiftpol-parameterize">swiftpol.parameterize</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">swiftpol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">openff.toolkit.utils.rdkit_wrapper</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for openff.toolkit.utils.rdkit_wrapper</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Wrapper class providing a minimal consistent interface to the `RDKit &lt;http://www.rdkit.org/&gt;`.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;RDKitToolkitWrapper&quot;</span><span class="p">,)</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cachetools</span> <span class="kn">import</span> <span class="n">LRUCache</span><span class="p">,</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">openff.units.elements</span> <span class="kn">import</span> <span class="n">SYMBOLS</span>

<span class="kn">from</span> <span class="nn">openff.toolkit</span> <span class="kn">import</span> <span class="n">Quantity</span><span class="p">,</span> <span class="n">unit</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils</span> <span class="kn">import</span> <span class="n">base_wrapper</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ALLOWED_AROMATICITY_MODELS</span><span class="p">,</span>
    <span class="n">DEFAULT_AROMATICITY_MODEL</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openff.toolkit.utils.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AmbiguousAtomChemicalAssignment</span><span class="p">,</span>
    <span class="n">AmbiguousBondChemicalAssignment</span><span class="p">,</span>
    <span class="n">ChargeMethodUnavailableError</span><span class="p">,</span>
    <span class="n">ConformerGenerationError</span><span class="p">,</span>
    <span class="n">EmptyInChiError</span><span class="p">,</span>
    <span class="n">InChIParseError</span><span class="p">,</span>
    <span class="n">InvalidAromaticityModelError</span><span class="p">,</span>
    <span class="n">MoleculeParseError</span><span class="p">,</span>
    <span class="n">MultipleComponentsInMoleculeWarning</span><span class="p">,</span>
    <span class="n">NonUniqueSubstructureName</span><span class="p">,</span>
    <span class="n">NotAttachedToMoleculeError</span><span class="p">,</span>
    <span class="n">RadicalsNotSupportedError</span><span class="p">,</span>
    <span class="n">SMILESParseError</span><span class="p">,</span>
    <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">,</span>
    <span class="n">SubstructureBondSmartsInvalid</span><span class="p">,</span>
    <span class="n">SubstructureImproperlySpecified</span><span class="p">,</span>
    <span class="n">ToolkitUnavailableException</span><span class="p">,</span>
    <span class="n">UnassignedChemistryInPDBError</span><span class="p">,</span>
    <span class="n">UndefinedStereochemistryError</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">openff.toolkit.topology.molecule</span> <span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Bond</span><span class="p">,</span> <span class="n">Molecule</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">normalize_file_format</span><span class="p">(</span><span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">file_format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_require_text_file_obj</span><span class="p">(</span><span class="n">file_obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">file_obj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># Switch to a ValueError and use a more informative exception</span>
        <span class="c1"># message to match RDKit&#39;s toolkit writer.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Need a text mode file object like StringIO or a file opened with mode &#39;t&#39;&quot;</span>
        <span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">RDKitToolkitWrapper</span><span class="p">(</span><span class="n">base_wrapper</span><span class="o">.</span><span class="n">ToolkitWrapper</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RDKit toolkit wrapper</span>

<span class="sd">    .. warning :: This API is experimental and subject to change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_toolkit_name</span> <span class="o">=</span> <span class="s2">&quot;The RDKit&quot;</span>
    <span class="n">_toolkit_installation_instructions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;A conda-installable version of the free and open source RDKit cheminformatics &quot;</span>
        <span class="s2">&quot;toolkit can be found at: https://anaconda.org/conda-forge/rdkit&quot;</span>
    <span class="p">)</span>

    <span class="n">_supported_charge_methods</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mmff94&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(),</span> <span class="s2">&quot;gasteiger&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()}</span>

    <span class="n">SUPPORTED_CHARGE_METHODS</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_supported_charge_methods</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># TODO: Add TDT support</span>
    <span class="n">_toolkit_file_read_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SDF&quot;</span><span class="p">,</span> <span class="s2">&quot;MOL&quot;</span><span class="p">,</span> <span class="s2">&quot;SMI&quot;</span><span class="p">]</span>
    <span class="n">_toolkit_file_write_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SDF&quot;</span><span class="p">,</span> <span class="s2">&quot;MOL&quot;</span><span class="p">,</span> <span class="s2">&quot;SMI&quot;</span><span class="p">,</span> <span class="s2">&quot;PDB&quot;</span><span class="p">,</span> <span class="s2">&quot;TDT&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ToolkitUnavailableException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The required toolkit </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_toolkit_name</span><span class="si">}</span><span class="s2"> is not &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;available. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_toolkit_installation_instructions</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">rdkit_version</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_toolkit_version</span> <span class="o">=</span> <span class="n">rdkit_version</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">toolkit_file_write_formats</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of file formats that this toolkit can write.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_toolkit_file_write_formats</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_available</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the RDKit toolkit can be imported</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_installed</span>
<span class="sd">            True if RDKit is installed, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_available</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;rdkit&quot;</span><span class="p">,</span> <span class="s2">&quot;Chem&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_is_available</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_is_available</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_available</span>

    <span class="k">def</span> <span class="nf">from_object</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If given an rdchem.Mol (or rdchem.Mol-derived object), this function will load it into an</span>
<span class="sd">        openff.toolkit.topology.molecule. Otherwise, it will return False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj</span>
<span class="sd">            An object to be type-checked and converted into a Molecule, if possible.</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            Whether to accept molecules with undefined stereocenters. If False,</span>
<span class="sd">            an exception will be raised if a molecule with undefined stereochemistry</span>
<span class="sd">            is passed into this function.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Molecule or False</span>
<span class="sd">            An openff.toolkit.topology.molecule Molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the object could not be converted into a Molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Add tests for the from_object functions</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="k">if</span> <span class="n">_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openff.toolkit.topology.molecule</span> <span class="kn">import</span> <span class="n">Molecule</span>

            <span class="n">_cls</span> <span class="o">=</span> <span class="n">Molecule</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_cls</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
                <span class="n">obj</span><span class="p">,</span>
                <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot create Molecule from </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> object&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_pdb_and_smiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from a pdb file and a SMILES string using RDKit.</span>

<span class="sd">        Requires RDKit to be installed.</span>

<span class="sd">        The molecule is created and sanitised based on the SMILES string, we then find a mapping</span>
<span class="sd">        between this molecule and one from the PDB based only on atomic number and connections.</span>
<span class="sd">        The SMILES molecule is then reindexed to match the PDB, the conformer is attached, and the</span>
<span class="sd">        molecule returned.</span>

<span class="sd">        Note that any stereochemistry in the molecule is set by the SMILES, and not the coordinates</span>
<span class="sd">        of the PDB.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path</span>
<span class="sd">            PDB file path</span>
<span class="sd">        smiles</span>
<span class="sd">            a valid smiles string for the pdb, used for stereochemistry, formal charges, and bond order</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            If false, raises an exception if SMILES contains undefined stereochemistry.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>
<span class="sd">        name</span>
<span class="sd">            An optional name for the output molecule</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        molecule</span>
<span class="sd">            An OFFMol instance with ordering the same as used in the PDB file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidConformerError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;`RDKitToolkitWrapper.from_polymer_pdb` is deprecated in favor of `Topology.from_pdb`, the recommended &quot;</span>
            <span class="s2">&quot;method for loading PDB files. (Note the `unique_molecules` argument.) This method will &quot;</span>
            <span class="s2">&quot;be removed in a future release of the OpenFF Toolkit.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Make the molecule from smiles</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span>
            <span class="n">smiles</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Make another molecule from the PDB. We squelch stereo errors here, since</span>
        <span class="c1"># RDKit&#39;s PDB loader doesn&#39;t attempt to perceive stereochemistry, bond order,</span>
        <span class="c1"># or formal charge (and we don&#39;t need those here).</span>
        <span class="n">prev_log_level</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
        <span class="n">pdbmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromPDBFile</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">prev_log_level</span><span class="p">)</span>

        <span class="c1"># check isomorphic and get the mapping if true the mapping will be</span>
        <span class="c1"># dict[offmol_index, pdbmol_index] sorted by offmol index</span>
        <span class="n">isomorphic</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">_cls</span><span class="o">.</span><span class="n">are_isomorphic</span><span class="p">(</span>
            <span class="n">offmol</span><span class="p">,</span>
            <span class="n">pdbmol</span><span class="p">,</span>
            <span class="n">return_atom_map</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">aromatic_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">formal_charge_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">bond_order_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">atom_stereochemistry_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">bond_stereochemistry_matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openff.toolkit.topology.molecule</span> <span class="kn">import</span> <span class="n">InvalidConformerError</span>

            <span class="k">raise</span> <span class="n">InvalidConformerError</span><span class="p">(</span><span class="s2">&quot;The PDB and SMILES structures do not match.&quot;</span><span class="p">)</span>

        <span class="n">new_mol</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>

        <span class="c1"># the pdb conformer is in the correct order so just attach it here</span>
        <span class="n">new_mol</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">pdbmol</span><span class="o">.</span><span class="n">conformers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Take residue info from PDB</span>
        <span class="k">for</span> <span class="n">pdbatom</span><span class="p">,</span> <span class="n">newatom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pdbmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">new_mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">newatom</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pdbatom</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">newatom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">pdbatom</span><span class="o">.</span><span class="n">name</span>
        <span class="n">new_mol</span><span class="o">.</span><span class="n">add_default_hierarchy_schemes</span><span class="p">()</span>

        <span class="n">new_mol</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">new_mol</span>

    <span class="k">def</span> <span class="nf">_polymer_openmm_topology_to_offmol</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">molecule_class</span><span class="p">,</span> <span class="n">omm_top</span><span class="p">,</span> <span class="n">substructure_dictionary</span>
    <span class="p">):</span>
        <span class="n">rdkit_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymer_openmm_topology_to_rdmol</span><span class="p">(</span>
            <span class="n">omm_top</span><span class="p">,</span> <span class="n">substructure_dictionary</span>
        <span class="p">)</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="n">molecule_class</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">offmol</span>

    <span class="k">def</span> <span class="nf">_polymer_openmm_pdbfile_to_offtop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">topology_class</span><span class="p">,</span>
        <span class="n">pdbfile</span><span class="p">,</span>
        <span class="n">substructure_dictionary</span><span class="p">,</span>
        <span class="n">coords_angstrom</span><span class="p">,</span>
        <span class="n">_custom_substructures</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">import</span> <span class="nn">json</span>

        <span class="kn">from</span> <span class="nn">openff.units.openmm</span> <span class="kn">import</span> <span class="n">from_openmm</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span><span class="p">,</span> <span class="n">Geometry</span>
        <span class="kn">from</span> <span class="nn">rdkit.DataStructs.cDataStructs</span> <span class="kn">import</span> <span class="n">BitVectToBinaryText</span>

        <span class="n">omm_top</span> <span class="o">=</span> <span class="n">pdbfile</span><span class="o">.</span><span class="n">topology</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_custom_substructures</span><span class="p">:</span>
            <span class="n">_custom_substructures</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># if custom substructures exist, validate them and add to the substructure_dictionary</span>
        <span class="c1"># (existing amino acid substructures are already validated as part of their creation)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_custom_substructures</span><span class="p">(</span>  <span class="c1"># errors if any errors found</span>
            <span class="n">_custom_substructures</span><span class="p">,</span> <span class="n">forbidden_keys</span><span class="o">=</span><span class="n">substructure_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">custom_substructure_dictionary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_custom_substructures</span><span class="p">(</span>
            <span class="n">_custom_substructures</span>
        <span class="p">)</span>
        <span class="n">substructure_dictionary</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">custom_substructure_dictionary</span>
        <span class="p">)</span>  <span class="c1"># concats both dicts, unique keys are enforced in previous function</span>

        <span class="n">rdkit_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polymer_openmm_topology_to_rdmol</span><span class="p">(</span>
            <span class="n">omm_top</span><span class="p">,</span> <span class="n">substructure_dictionary</span>
        <span class="p">)</span>

        <span class="n">rdmol_conformer</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Conformer</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">coords_angstrom</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">rdmol_conformer</span><span class="o">.</span><span class="n">SetAtomPosition</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">,</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">Point3D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
        <span class="n">rdkit_mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">rdmol_conformer</span><span class="p">,</span> <span class="n">assignId</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
            <span class="n">rdkit_mol</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistryFrom3D</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">,</span> <span class="n">clearAromaticFlags</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>

        <span class="c1"># Don&#39;t sanitize or we risk assigning non-MDL aromaticity</span>
        <span class="n">rdmols</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">,</span> <span class="n">asMols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sanitizeFrags</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">topology_class</span><span class="p">()</span>

        <span class="c1"># Identify unique molecules and only run from_rdkit on them once.</span>
        <span class="c1"># Note that this identity comparison COULD match two chemically equivalent</span>
        <span class="c1"># atoms with different atom names, but that doesn&#39;t matter because we do</span>
        <span class="c1"># the metadata assignment and coordinate setting outside this method, so</span>
        <span class="c1"># as long as a chemically equivalent atom is sitting at the right index</span>
        <span class="c1"># in the topology when the metadata is assigned there&#39;s no difference.</span>
        <span class="n">smiles2offmol</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rdmol</span> <span class="ow">in</span> <span class="n">rdmols</span><span class="p">:</span>
            <span class="c1"># Make a copy of the molecule to assign atom maps, since</span>
            <span class="c1"># otherwise the atom maps will mess with stereo assignment.</span>
            <span class="n">mapped_rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mapped_rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
                <span class="c1"># the mapping must start from 1, as RDKit uses 0 to represent no mapping.</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetAtomMapNum</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mapped_smi</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mapped_rdmol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mapped_smi</span> <span class="ow">in</span> <span class="n">smiles2offmol</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">offmol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">smiles2offmol</span><span class="p">[</span><span class="n">mapped_smi</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># assign metadata</span>
                <span class="k">for</span> <span class="n">offatom</span><span class="p">,</span> <span class="n">rdatom</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offmol</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
                    <span class="n">res_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span>
                        <span class="n">BitVectToBinaryText</span><span class="p">(</span><span class="n">rdatom</span><span class="o">.</span><span class="n">GetExplicitBitVectProp</span><span class="p">(</span><span class="s2">&quot;res_ids&quot;</span><span class="p">)),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">query_nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span>
                        <span class="n">BitVectToBinaryText</span><span class="p">(</span>
                            <span class="n">rdatom</span><span class="o">.</span><span class="n">GetExplicitBitVectProp</span><span class="p">(</span><span class="s2">&quot;query_nums&quot;</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">query_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span>
                        <span class="n">BitVectToBinaryText</span><span class="p">(</span><span class="n">rdatom</span><span class="o">.</span><span class="n">GetExplicitBitVectProp</span><span class="p">(</span><span class="s2">&quot;query_ids&quot;</span><span class="p">)),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">residues</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="nb">list</span><span class="p">(</span><span class="n">substructure_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">res_ids</span>
                    <span class="p">]</span>
                    <span class="c1"># query_ids = [int(idx) for idx in list(query_ids)]</span>
                    <span class="n">match_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">res_name</span><span class="p">,</span> <span class="n">query_idx</span><span class="p">,</span> <span class="n">query_num</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                        <span class="n">residues</span><span class="p">,</span> <span class="n">query_ids</span><span class="p">,</span> <span class="n">query_nums</span>
                    <span class="p">):</span>
                        <span class="n">match_info</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">query_num</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">res_name</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">query_idx</span><span class="p">))</span>
                    <span class="n">offatom</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;match_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">match_info</span><span class="p">)</span>
                <span class="n">smiles2offmol</span><span class="p">[</span><span class="n">mapped_smi</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">offmol</span><span class="p">)</span>
            <span class="n">top</span><span class="o">.</span><span class="n">_add_molecule_keep_cache</span><span class="p">(</span><span class="n">offmol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pdbfile</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">getPeriodicBoxVectors</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top</span><span class="o">.</span><span class="n">box_vectors</span> <span class="o">=</span> <span class="n">from_openmm</span><span class="p">(</span><span class="n">pdbfile</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">getPeriodicBoxVectors</span><span class="p">())</span>
        <span class="n">top</span><span class="o">.</span><span class="n">set_positions</span><span class="p">(</span><span class="n">coords_angstrom</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">top</span>

    <span class="k">def</span> <span class="nf">_validate_custom_substructures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">custom_substructures</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">forbidden_keys</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates custom substructures to adhere to monomer specifications</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        custom_substructures</span>
<span class="sd">            substructures given with unique names as keys and smarts as values</span>
<span class="sd">        forbidden_keys</span>
<span class="sd">            a list of keys that cannot overlap with the custom substructure keys</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None: If validation successful. Errors otherwise</span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NonUniqueSubstructureName</span>
<span class="sd">            Raised when any substructures have nonunique names or names that</span>
<span class="sd">            conflict with toolkit substructure names (such as protein residue names)</span>
<span class="sd">        SubstructureAtomSmartsInvalid</span>
<span class="sd">            Raised when any atom smarts are improperly formatted</span>
<span class="sd">        SubstructureBondSmartsInvalid</span>
<span class="sd">            Raised when any bond smarts are improperly formatted</span>
<span class="sd">        SubstructureImproperlySpecified</span>
<span class="sd">            Raised when the custom substructure is inadequately specified or</span>
<span class="sd">            contains conflicting information</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ensure no duplicate keys</span>
        <span class="n">custom_keys</span> <span class="o">=</span> <span class="n">custom_substructures</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">same_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">forbidden_keys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">custom_keys</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">same_keys</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NonUniqueSubstructureName</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">same_keys</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts_list</span> <span class="ow">in</span> <span class="n">custom_substructures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">smarts</span> <span class="ow">in</span> <span class="n">smarts_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_valid_substructure_smarts</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">smarts</span>
                <span class="p">)</span>  <span class="c1"># raises error if invalid</span>

        <span class="k">return</span>  <span class="c1"># all tests passed without raised exception</span>

    <span class="k">def</span> <span class="nf">_is_valid_substructure_smarts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="k">def</span> <span class="nf">check_is_connected</span><span class="p">(</span><span class="n">rdmol</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">rdmolops</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">rdmol</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="s2">&quot;Multiple fragments detected. Must be a single and connected substructure.&quot;</span>
                <span class="k">raise</span> <span class="n">SubstructureImproperlySpecified</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">error_reason</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">check_interior_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">qmol</span><span class="p">):</span>
            <span class="n">atom_smarts</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">()</span>
            <span class="c1"># ensure that no unsupported logical operators exist</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;!,;&quot;</span>
            <span class="n">found_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">found_ops</span><span class="p">):</span>
                <span class="n">operator_chars</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">found_ops</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found unsupported logical operator(s): </span><span class="si">{</span><span class="n">operator_chars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="c1"># ensure that no other unsupported atomic primitives are accepted</span>
            <span class="n">unsupported_prims</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;@xXvrRhH*&quot;</span>
            <span class="n">found_prims</span> <span class="o">=</span> <span class="p">[</span><span class="n">prim</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">unsupported_prims</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">found_prims</span><span class="p">):</span>
                <span class="n">operator_chars</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">prim</span> <span class="k">for</span> <span class="n">prim</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unsupported_prims</span><span class="p">,</span> <span class="n">found_prims</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span>
                <span class="p">]</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;found unsupported primitive(s): </span><span class="si">{</span><span class="n">operator_chars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="c1"># require that all elements are specified in #&lt;n&gt; format. Because the H primitive can act as either</span>
            <span class="c1"># hydrogen atom or the number of implicit hydrogens, it is cleaner to specify atoms by atomic number</span>
            <span class="c1"># rather than atomic symbol.</span>
            <span class="c1"># Also require explicit connecitivity in D&lt;n&gt; format and explicit charge with either a + or -</span>
            <span class="n">required_prims</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[]#D:&quot;</span>
            <span class="n">missing_prims</span> <span class="o">=</span> <span class="p">[</span><span class="n">prim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">required_prims</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">missing_prims</span><span class="p">):</span>
                <span class="n">operator_chars</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">prim</span> <span class="k">for</span> <span class="n">prim</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">required_prims</span><span class="p">,</span> <span class="n">missing_prims</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span>
                <span class="p">]</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;required primitive(s) not included: </span><span class="si">{</span><span class="n">operator_chars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="n">charge_prims</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;-+&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">prim</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">charge_prims</span><span class="p">):</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom_smarts</span><span class="si">}</span><span class="s2">: no charge primitive (+ or -) on atom&quot;</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atom</span><span class="o">.</span><span class="n">Match</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;query does not match rdchem.Mol reading of the molecule (likely due to incorrect&quot;</span>
                    <span class="s2">&quot;/ambiguous connectivity)&quot;</span>
                <span class="p">)</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">check_neighbor_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">qmol</span><span class="p">):</span>
            <span class="n">atom_smarts</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">()</span>
            <span class="c1"># ensure that no unsupported logical operators exist</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;!,;&amp;&quot;</span>
            <span class="n">found_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">found_ops</span><span class="p">):</span>
                <span class="n">operator_chars</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">found_ops</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;found unsupported logical operator(s): </span><span class="si">{</span><span class="n">operator_chars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="c1"># ensure that no other unsupported atomic primitives are accepted</span>
            <span class="n">unsupported_prims</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;@xXDvrRhH&quot;</span>
            <span class="n">found_prims</span> <span class="o">=</span> <span class="p">[</span><span class="n">prim</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">unsupported_prims</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">found_prims</span><span class="p">):</span>
                <span class="n">operator_chars</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">prim</span> <span class="k">for</span> <span class="n">prim</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unsupported_prims</span><span class="p">,</span> <span class="n">found_prims</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span>
                <span class="p">]</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;found unsupported primitive(s): </span><span class="si">{</span><span class="n">operator_chars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="c1"># require that atoms have a wildtype atom and label</span>
            <span class="n">required_prims</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[]*:&quot;</span>
            <span class="n">missing_prims</span> <span class="o">=</span> <span class="p">[</span><span class="n">prim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_smarts</span> <span class="k">for</span> <span class="n">prim</span> <span class="ow">in</span> <span class="n">required_prims</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">missing_prims</span><span class="p">):</span>
                <span class="n">operator_chars</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">prim</span> <span class="k">for</span> <span class="n">prim</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">required_prims</span><span class="p">,</span> <span class="n">missing_prims</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span>
                <span class="p">]</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;required primitive(s) not included: </span><span class="si">{</span><span class="n">operator_chars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">check_bond</span><span class="p">(</span><span class="n">bond</span><span class="p">):</span>
            <span class="n">valid_bond_types</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">TRIPLE</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_bond_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SubstructureBondSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">bond</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">valid_bond_types</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">qmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>

        <span class="c1"># check if graph is connected</span>
        <span class="n">check_is_connected</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>

        <span class="c1"># check atom strings for required and unsupported primitives</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">check_interior_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">qmol</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s2">&quot;#&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">():</span>
                <span class="n">check_neighbor_atom</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">qmol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol_smarts</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmarts</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="n">error_reason</span> <span class="o">=</span> <span class="s2">&quot;atomic num = 0 but smarts contains # primitive (likely due to conditionals)&quot;</span>
                <span class="k">raise</span> <span class="n">SubstructureAtomSmartsInvalid</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSmarts</span><span class="p">(),</span> <span class="n">mol_smarts</span><span class="p">,</span> <span class="n">error_reason</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">check_bond</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>

        <span class="c1"># ensure unique atom map numbers for each atom</span>
        <span class="n">map_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()]</span>
        <span class="n">unique_map_nums</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">map_nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_nums</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_map_nums</span><span class="p">):</span>
            <span class="n">reason</span> <span class="o">=</span> <span class="s2">&quot;non-unique atom map numbers detected&quot;</span>
            <span class="k">raise</span> <span class="n">SubstructureImproperlySpecified</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">reason</span><span class="p">)</span>

        <span class="c1"># If all checks pass, continue</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_prepare_custom_substructures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">custom_substructures</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds general atom names to match the format of the amino acid substructure dict</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        custom_substructures</span>
<span class="sd">            substructures given with unique names as keys and smarts as values</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prepared_dict</span>
<span class="sd">            a dictionary of the same type and format as the predefined toolkit</span>
<span class="sd">            substructures (amino acids, etc). Atom names are given the format</span>
<span class="sd">            &quot;CSTM_{symbol}&quot;, including wildtypes which show as &quot;CSTM_*&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">prepared_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]](</span>
            <span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">smarts_list</span> <span class="ow">in</span> <span class="n">custom_substructures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">smarts</span> <span class="ow">in</span> <span class="n">smarts_list</span><span class="p">:</span>
                <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>
                <span class="n">atom_list</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CSTM_</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()]</span>
                <span class="n">prepared_dict</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">smarts</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_list</span>
        <span class="k">return</span> <span class="n">prepared_dict</span>

    <span class="k">def</span> <span class="nf">_polymer_openmm_topology_to_rdmol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omm_top</span><span class="p">,</span> <span class="n">substructure_library</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdkit_mol</span>
<span class="sd">            Currently invalid (bond orders and charge) Molecule</span>
<span class="sd">        substructure_library</span>
<span class="sd">            A dictionary of substructures. substructure_library[aa_name] = list[tagged SMARTS, list[atom_names]]</span>
<span class="sd">        toolkit_registry</span>
<span class="sd">            Either a ToolkitRegistry, ToolkitWrapper</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rdkit_mol</span>
<span class="sd">            a copy of the original molecule with charges and bond order added</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MissingChemistryFromPolymerError</span>
<span class="sd">            Raised when bonds or atoms in ``rdkit_mol`` are missing from the</span>
<span class="sd">            substructure library</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
        <span class="kn">from</span> <span class="nn">rdkit.DataStructs.cDataStructs</span> <span class="kn">import</span> <span class="n">CreateFromBinaryText</span>

        <span class="n">already_assigned_nodes</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># TODO: We currently assume all single and modify a few</span>
        <span class="c1"># Therefore it&#39;s hard to know if we&#39;ve missed any edges...</span>
        <span class="c1"># Notably assumes all bonds *between* fragments are single</span>
        <span class="n">already_assigned_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Keeping track of which atoms are matched where will help us with error</span>
        <span class="c1"># messages</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">residue_name_ids</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">query_nums</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">query_ids</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="n">rdkit_mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_connectivity_from_openmm_top</span><span class="p">(</span><span class="n">omm_top</span><span class="p">)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="p">)</span>
        <span class="c1"># Get a tuple of tuples of atom indices belonging to separate molecules in this RDMol</span>
        <span class="c1"># (note that this rdmol may actually be a solvated protein-ligand system)</span>
        <span class="n">sorted_mol_frags</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">mol</span><span class="p">)]</span>
        <span class="n">query_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">res_idx</span><span class="p">,</span> <span class="n">res_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">substructure_library</span><span class="p">):</span>
            <span class="c1"># TODO: This is a hack for the moment since we don&#39;t have a more sophisticated way to resolve clashes</span>
            <span class="c1"># so it just does the biggest substructures first</span>
            <span class="c1"># NOTE: If this changes, MissingChemistryFromPolymerError needs to be updated too</span>
            <span class="n">sorted_substructure_smarts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">substructure_library</span><span class="p">[</span><span class="n">res_name</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">substructure_smarts</span> <span class="ow">in</span> <span class="n">sorted_substructure_smarts</span><span class="p">:</span>
                <span class="c1"># this is the molecule as defined in template.</span>
                <span class="c1"># ref is used to execute queries and find substructures but is difficult to</span>
                <span class="c1"># sanitize/calculate valence (has query atoms)</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">substructure_smarts</span><span class="p">)</span>
                <span class="n">ref_info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
                <span class="c1"># ref must be sanitized to calculate aromaticity</span>
                <span class="c1"># run sanitization to calculate Implcit H counts to later aromaticity assignment</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
                    <span class="n">ref_info</span><span class="p">,</span>
                    <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_NONE</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># set aromaticity for ref to avoid ambiguous chemical assignments from rotating or</span>
                <span class="c1"># flipping aromatic rings.</span>
                <span class="c1"># The entire molecule is kekulized after</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">ref_info</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>

                <span class="c1"># then create a looser definition for pattern matching...</span>
                <span class="c1"># be lax about double bonds and chirality</span>
                <span class="n">fuzzy</span><span class="p">,</span> <span class="n">neighbor_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fuzzy_query</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
                <span class="c1"># It&#39;s important that we do the substructure search on `rdkit_mol`, but the chemical</span>
                <span class="c1"># info is added to `mol`. If we use the same rdkit molecule for search AND info addition,</span>
                <span class="c1"># then single bonds may no longer be present for subsequent overlapping matches.</span>
                <span class="n">sym_atoms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">sym_bonds</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">sym_atoms</span><span class="p">,</span> <span class="n">sym_bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_symmetrical_groups</span><span class="p">(</span><span class="n">fuzzy</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">full_match</span> <span class="ow">in</span> <span class="n">rdkit_mol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">fuzzy</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># Keep track of all residue names that have been assigned to</span>
                    <span class="c1"># each atom, for use in generating a useful error message later</span>
                    <span class="n">match_ids</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="p">(</span><span class="n">query_id</span><span class="p">,</span> <span class="n">mol_id</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">query_id</span><span class="p">,</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_match</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">query_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neighbor_idxs</span>
                    <span class="p">]</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">match_ids</span><span class="p">))[</span>
                        <span class="mi">1</span>
                    <span class="p">]</span>  <span class="c1"># get the molecule ids without the corresponding query ids.</span>
                    <span class="c1"># ^^ matches return match ids in the order that they appear in the query.</span>
                    <span class="c1"># The code above filters neighboring (*) atoms.</span>

                    <span class="c1"># Unique molecule matches should only apply if they match entire molecule</span>
                    <span class="k">if</span> <span class="n">res_name</span> <span class="o">==</span> <span class="s2">&quot;UNIQUE_MOLECULE&quot;</span><span class="p">:</span>
                        <span class="n">sorted_match</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">sorted_match</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sorted_mol_frags</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="c1"># assign chemical info and check all overlapping substructures for ambiguous/conflicting</span>
                    <span class="c1"># chemical info.</span>
                    <span class="k">for</span> <span class="n">atom_i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_info</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">(),</span> <span class="n">full_match</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">atom_i</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ignore neighboring atoms</span>
                            <span class="k">continue</span>
                        <span class="n">atom_j</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="c1"># error checking for overlapping substructures with priority. Enforce that no ambiguous</span>
                        <span class="c1"># chemical assignments are made.</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">j</span> <span class="ow">in</span> <span class="n">already_assigned_nodes</span>
                        <span class="p">):</span>  <span class="c1"># if overlapping with previous match</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">atom_i</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">!=</span> <span class="n">atom_j</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span>
                                <span class="ow">and</span> <span class="n">atom_i</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sym_atoms</span>
                            <span class="p">):</span>
                                <span class="n">error_reason</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Formal charge of new query (</span><span class="si">{</span><span class="n">atom_i</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span><span class="si">}</span><span class="s2">) does &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;not match the formal charge of previous query &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">atom_j</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
                                <span class="p">)</span>
                                <span class="k">raise</span> <span class="n">AmbiguousAtomChemicalAssignment</span><span class="p">(</span>
                                    <span class="n">res_name</span><span class="p">,</span>
                                    <span class="n">atom_j</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">(),</span>
                                    <span class="n">atom_i</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">(),</span>
                                    <span class="n">error_reason</span><span class="p">,</span>
                                <span class="p">)</span>

                        <span class="n">atom_j</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom_i</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">())</span>

                    <span class="n">already_assigned_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ref_info</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
                        <span class="n">ref_bond_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()])</span>
                        <span class="p">)</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">full_match</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()]</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">full_match</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()]</span>
                        <span class="n">b2</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">bond_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>

                        <span class="c1"># error checking of overlapping bonds. If substructures with priority disagree on the</span>
                        <span class="c1"># bond order, raise exception</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">bond_ids</span> <span class="ow">in</span> <span class="n">already_assigned_edges</span>
                        <span class="p">):</span>  <span class="c1"># if overlapping with previous match</span>
                            <span class="k">if</span> <span class="p">(</span>
                                <span class="n">b</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span>
                                <span class="ow">and</span> <span class="n">ref_bond_ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sym_bonds</span>
                            <span class="p">):</span>
                                <span class="n">error_reason</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Bond order of new query (</span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span><span class="si">}</span><span class="s2">) does not match the &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;bond order of previous query (</span><span class="si">{</span><span class="n">b2</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
                                <span class="p">)</span>
                                <span class="n">query_bond</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                                    <span class="nb">sorted</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()])</span>
                                <span class="p">)</span>
                                <span class="k">raise</span> <span class="n">AmbiguousBondChemicalAssignment</span><span class="p">(</span>
                                    <span class="n">res_name</span><span class="p">,</span> <span class="n">bond_ids</span><span class="p">,</span> <span class="n">query_bond</span><span class="p">,</span> <span class="n">error_reason</span>
                                <span class="p">)</span>
                        <span class="n">b2</span><span class="o">.</span><span class="n">SetBondType</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">())</span>
                        <span class="n">already_assigned_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bond_ids</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">query_id</span><span class="p">,</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">match_ids</span><span class="p">:</span>
                        <span class="n">matches</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_name</span><span class="p">)</span>
                        <span class="n">residue_name_ids</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">res_idx</span>
                        <span class="p">)</span>  <span class="c1"># save the minimum amount of information between the res_name and query ids</span>
                        <span class="n">query_nums</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">query_number</span><span class="p">)</span>
                        <span class="n">query_ids</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">query_id</span>
                        <span class="p">)</span>  <span class="c1"># that may allow someone to reproduce or fully investigate the matches</span>
                    <span class="n">query_number</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">unassigned_atoms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rdkit_mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()))</span> <span class="o">-</span> <span class="n">already_assigned_nodes</span>
        <span class="p">)</span>
        <span class="n">all_bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()]))</span>
                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">rdkit_mol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">unassigned_bonds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_bonds</span> <span class="o">-</span> <span class="n">already_assigned_edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unassigned_atoms</span> <span class="ow">or</span> <span class="n">unassigned_bonds</span><span class="p">:</span>
            <span class="c1"># Some advanced error reporting needs to interpret the substructure smarts to do things like</span>
            <span class="c1"># compare atom counts. Since OFFTK doesn&#39;t have a native class to hold fragments, we convert</span>
            <span class="c1"># the smarts into a sorted list of symbols to help with generating the error message.</span>
            <span class="n">resname_to_symbols_and_atomnames</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">resname</span><span class="p">,</span> <span class="n">smarts_to_atom_names</span> <span class="ow">in</span> <span class="n">substructure_library</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">resname_to_symbols_and_atomnames</span><span class="p">[</span><span class="n">resname</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">smarts</span><span class="p">,</span> <span class="n">atom_names</span> <span class="ow">in</span> <span class="n">smarts_to_atom_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>
                    <span class="n">symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">SYMBOLS</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()]</span>
                            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">resname_to_symbols_and_atomnames</span><span class="p">[</span><span class="n">resname</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">atom_names</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="k">raise</span> <span class="n">UnassignedChemistryInPDBError</span><span class="p">(</span>
                <span class="n">substructure_library</span><span class="o">=</span><span class="n">resname_to_symbols_and_atomnames</span><span class="p">,</span>
                <span class="n">omm_top</span><span class="o">=</span><span class="n">omm_top</span><span class="p">,</span>
                <span class="n">unassigned_atoms</span><span class="o">=</span><span class="n">unassigned_atoms</span><span class="p">,</span>
                <span class="n">unassigned_bonds</span><span class="o">=</span><span class="n">unassigned_bonds</span><span class="p">,</span>
                <span class="n">matches</span><span class="o">=</span><span class="n">matches</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># set some properties to later remember what matches were made</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom_id</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">res_ids</span> <span class="o">=</span> <span class="n">residue_name_ids</span><span class="p">[</span><span class="n">atom_id</span><span class="p">]</span>
            <span class="n">q_nums</span> <span class="o">=</span> <span class="n">query_nums</span><span class="p">[</span><span class="n">atom_id</span><span class="p">]</span>
            <span class="n">q_ids</span> <span class="o">=</span> <span class="n">query_ids</span><span class="p">[</span><span class="n">atom_id</span><span class="p">]</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetExplicitBitVectProp</span><span class="p">(</span>
                <span class="s2">&quot;res_ids&quot;</span><span class="p">,</span>
                <span class="n">CreateFromBinaryText</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res_ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()),</span>
            <span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetExplicitBitVectProp</span><span class="p">(</span>
                <span class="s2">&quot;query_nums&quot;</span><span class="p">,</span>
                <span class="n">CreateFromBinaryText</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q_nums</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()),</span>
            <span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetExplicitBitVectProp</span><span class="p">(</span>
                <span class="s2">&quot;query_ids&quot;</span><span class="p">,</span>
                <span class="n">CreateFromBinaryText</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">q_ids</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_get_connectivity_from_openmm_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omm_top</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="c1"># convert openmm topology to rdkit Molecule</span>
        <span class="c1"># all bonds initially SINGLE, all charge initially neutral</span>
        <span class="n">rwmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">omm_top</span><span class="o">.</span><span class="n">atoms</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">rwmol</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AtomPDBResidueInfo</span><span class="p">()</span>
            <span class="n">res</span><span class="o">.</span><span class="n">SetResidueName</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">SetResidueNumber</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">SetChainId</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">rwatom</span> <span class="o">=</span> <span class="n">rwmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">rwatom</span><span class="o">.</span><span class="n">SetPDBResidueInfo</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="c1"># we&#39;re fully explicit</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">rwmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetNoImplicit</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">omm_top</span><span class="o">.</span><span class="n">bonds</span><span class="p">():</span>
            <span class="n">rwmol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rwmol</span>

    <span class="k">def</span> <span class="nf">_get_symmetrical_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fuzzy_query</span><span class="p">,</span> <span class="n">substruct</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns those atoms and bonds whose chemical information</span>
<span class="sd">        is ambiguous due to resonance forms or symmetrical groups. Conflicts</span>
<span class="sd">        in assignment are ignored for these atoms when two queries have the same</span>
<span class="sd">        atoms in resonance/symmetry&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">qmol</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">fuzzy_query</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>  <span class="c1"># reset queries and map numbers</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">SetAtomMapNum</span><span class="p">(</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># reorder atom map nums to later recover ids</span>

        <span class="n">qmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveAllHs</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
        <span class="n">idx_to_map_num</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">())</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()]</span>
        <span class="p">)</span>
        <span class="n">automorphs</span> <span class="o">=</span> <span class="n">fuzzy_query</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">qmol</span><span class="p">,</span> <span class="n">uniquify</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ambiguous_bonds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ambiguous_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">automorph</span> <span class="ow">in</span> <span class="n">automorphs</span><span class="p">:</span>
            <span class="c1"># check for conflicting chemical information</span>
            <span class="n">automorph</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span><span class="n">idx_to_map_num</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">automorph</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">idx_to_map_num</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span>
                <span class="p">]</span>
            <span class="p">)</span>  <span class="c1"># only care about cases of different matching</span>

            <span class="k">for</span> <span class="n">atom_iso</span><span class="p">,</span> <span class="n">new_atom_iso</span> <span class="ow">in</span> <span class="n">automorph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">substruct</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_iso</span><span class="p">)</span>
                <span class="n">new_atom</span> <span class="o">=</span> <span class="n">substruct</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">new_atom_iso</span><span class="p">)</span>
                <span class="c1"># new_atom = substruct.GetAtomWithIdx(automorph[atom.GetIdx()])</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span> <span class="o">!=</span> <span class="n">new_atom</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ambiguous_atoms</span><span class="p">:</span>
                        <span class="n">ambiguous_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">substruct</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtom</span><span class="p">()</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="ow">or</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtom</span><span class="p">()</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="p">):</span>  <span class="c1"># we remove Hs for matching so must remove here as well</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span> <span class="ow">in</span> <span class="n">automorph</span>
                    <span class="ow">or</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span> <span class="ow">in</span> <span class="n">automorph</span>
                <span class="p">):</span>
                    <span class="n">new_bond_begin_idx</span> <span class="o">=</span> <span class="n">automorph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">new_bond_end_idx</span> <span class="o">=</span> <span class="n">automorph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span>
                    <span class="p">)</span>
                    <span class="n">new_bond</span> <span class="o">=</span> <span class="n">substruct</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span>
                        <span class="n">new_bond_begin_idx</span><span class="p">,</span> <span class="n">new_bond_end_idx</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">new_bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">():</span>
                        <span class="n">sym_bond_entry</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="nb">sorted</span><span class="p">([</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()])</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">sym_bond_entry</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ambiguous_bonds</span><span class="p">:</span>
                            <span class="n">ambiguous_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="nb">tuple</span><span class="p">(</span>
                                    <span class="nb">sorted</span><span class="p">(</span>
                                        <span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()]</span>
                                    <span class="p">)</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ambiguous_bonds</span><span class="p">:</span>
            <span class="n">ambiguous_atoms</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[]</span>
            <span class="p">)</span>  <span class="c1"># if no ambiguous bonds, there cannot be physically valid sets of ambiguous atoms</span>
            <span class="c1"># this is because that would imply that two different simple/graph connectivites can give different</span>
            <span class="c1"># formal charges, which is not supported in this implementation and likely not possible outside of</span>
            <span class="c1"># exotic transition metal groups</span>
        <span class="k">return</span> <span class="n">ambiguous_atoms</span><span class="p">,</span> <span class="n">ambiguous_bonds</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fuzzy_query</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return a copy of Query which is less specific:</span>
<span class="sd">        - ignore aromaticity and hybridization of atoms (i.e. [#6] not C)</span>
<span class="sd">        - ignore bond orders</span>
<span class="sd">        - ignore formal charges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="c1"># it&#39;s tricky from the Python API to properly edit queries,</span>
        <span class="c1"># but you can do SetQuery on Atoms/Bonds to edit them quite powerfully</span>
        <span class="n">generic</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="s2">&quot;**&quot;</span><span class="p">)</span>
        <span class="n">generic_bond</span> <span class="o">=</span> <span class="n">generic</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">fuzzy</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">neighbor_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fuzzy</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
            <span class="n">a</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">SetQuery</span><span class="p">(</span>
                    <span class="n">Chem</span><span class="o">.</span><span class="n">AtomFromSmarts</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[#</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span><span class="si">}</span><span class="s2">D</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">GetDegree</span><span class="p">()</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">SetQuery</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">a</span><span class="o">.</span><span class="n">SetNoImplicit</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">neighbor_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">fuzzy</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">b</span><span class="o">.</span><span class="n">SetIsAromatic</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">SetBondType</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">SetQuery</span><span class="p">(</span><span class="n">generic_bond</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fuzzy</span><span class="p">,</span> <span class="n">neighbor_idxs</span>

    <span class="k">def</span> <span class="nf">_assign_aromaticity_and_stereo_from_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offmol</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span>
            <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span><span class="p">,</span>  <span class="c1"># ^ Chem.SANITIZE_SETAROMATICITY,</span>
        <span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistryFrom3D</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">clearAromaticFlags</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>
        <span class="c1"># To get HIS//TRP to get recognized as aromatic, we can use a different aromaticity model</span>
        <span class="c1"># Chem.SetAromaticity(rdmol, Chem.AromaticityModel.AROMATICITY_DEFAULT)</span>

        <span class="n">offmol_w_stereo_and_aro</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">offmol_w_stereo_and_aro</span>

    <span class="k">def</span> <span class="nf">_process_sdf_supplier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sdf_supplier</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="p">):</span>
        <span class="s2">&quot;Helper function to process RDKit molecules from an SDF input source&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="k">for</span> <span class="n">rdmol</span> <span class="ow">in</span> <span class="n">sdf_supplier</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rdmol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Sanitize the molecules (fails on nitro groups)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
                    <span class="n">rdmol</span><span class="p">,</span>
                    <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span>
                    <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_SETAROMATICITY</span>
                    <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistryFrom3D</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
                <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an openff.toolkit.topology.Molecule from a file using this toolkit.</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path</span>
<span class="sd">            The file to read the molecule from</span>
<span class="sd">        file_format</span>
<span class="sd">            Format specifier, usually file suffix (eg. &#39;MOL2&#39;, &#39;SMI&#39;)</span>
<span class="sd">            Note that not all toolkits support all formats. Check</span>
<span class="sd">            ToolkitWrapper.toolkit_file_read_formats for details.</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            If false, raises an exception if RDMol contains undefined stereochemistry.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules</span>
<span class="sd">            a list of Molecule objects is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
            <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>  <span class="c1"># type: ignore[no-redef]</span>

        <span class="n">file_format</span> <span class="o">=</span> <span class="n">normalize_file_format</span><span class="p">(</span><span class="n">file_format</span><span class="p">)</span>

        <span class="n">mols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;MOL&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;SDF&quot;</span><span class="p">):</span>
            <span class="n">sdf_supplier</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ForwardSDMolSupplier</span><span class="p">(</span>
                <span class="n">file_path</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strictParsing</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">mols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_sdf_supplier</span><span class="p">(</span>
                    <span class="n">sdf_supplier</span><span class="p">,</span>
                    <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                    <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;SMI&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: We have to do some special stuff when we import SMILES (currently</span>
            <span class="c1"># just adding H&#39;s, but could get fancier in the future). It might be</span>
            <span class="c1"># worthwhile to parse the SMILES file ourselves and pass each SMILES</span>
            <span class="c1"># through the from_smiles function instead</span>
            <span class="k">for</span> <span class="n">rdmol</span> <span class="ow">in</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SmilesMolSupplier</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">titleLine</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rdmol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Skip any lines that could not be processed.</span>
                    <span class="c1"># This is consistent with the SDF reader and with</span>
                    <span class="c1"># the OpenEye toolkit wrapper.</span>
                    <span class="k">continue</span>
                <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
                    <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span>
                <span class="p">)</span>
                <span class="n">mols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;PDB&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeParseError</span><span class="p">(</span>
                <span class="s2">&quot;RDKit can not safely read PDBs on their own. Information about bond order &quot;</span>
                <span class="s2">&quot;and aromaticity is likely to be lost. To read a PDB using RDKit use &quot;</span>
                <span class="s2">&quot;Molecule.from_pdb_and_smiles()&quot;</span>
            <span class="p">)</span>
            <span class="c1"># TODO: See if we can implement PDB+mol/smi combinations to get complete bond information.</span>
            <span class="c1">#  testing to see if we can make a molecule from smiles and then use the PDB</span>
            <span class="c1">#  conformer as the geometry and just reorder the molecule</span>
            <span class="c1"># https://github.com/openforcefield/openff-toolkit/issues/121</span>
            <span class="c1"># rdmol = Chem.MolFromPDBFile(file_path, removeHs=False)</span>
            <span class="c1"># mol = Molecule.from_rdkit(rdmol, _cls=_cls)</span>
            <span class="c1"># mols.append(mol)</span>
            <span class="c1"># TODO: Add SMI, TDT(?) support</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported file format: </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mols</span>

    <span class="k">def</span> <span class="nf">from_file_obj</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_obj</span><span class="p">,</span>
        <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an openff.toolkit.topology.Molecule from a file-like object using this toolkit.</span>

<span class="sd">        A file-like object is an object with a &quot;.read()&quot; method.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_obj</span>
<span class="sd">            The file-like object to read the molecule from</span>
<span class="sd">        file_format</span>
<span class="sd">            Format specifier, usually file suffix (eg. &#39;MOL2&#39;, &#39;SMI&#39;)</span>
<span class="sd">            Note that not all toolkits support all formats. Check</span>
<span class="sd">            ToolkitWrapper.toolkit_file_read_formats for details.</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            If false, raises an exception if RDMol contains undefined stereochemistry.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules</span>
<span class="sd">            a list of Molecule objects is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">mols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">file_format</span> <span class="o">=</span> <span class="n">normalize_file_format</span><span class="p">(</span><span class="n">file_format</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;MOL&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;SDF&quot;</span><span class="p">):</span>
            <span class="c1"># TODO: Iterate over all mols in file_data</span>
            <span class="n">sdf_supplier</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ForwardSDMolSupplier</span><span class="p">(</span>
                <span class="n">file_obj</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strictParsing</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">mols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_process_sdf_supplier</span><span class="p">(</span>
                    <span class="n">sdf_supplier</span><span class="p">,</span>
                    <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                    <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;SMI&quot;</span><span class="p">:</span>
            <span class="c1"># There&#39;s no good way to create a SmilesMolSuppler from a string</span>
            <span class="c1"># other than to use a temporary file.</span>
            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.smi&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmpfile</span><span class="p">:</span>
                <span class="n">content</span> <span class="o">=</span> <span class="n">file_obj</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="c1"># Backwards compatibility. Older versions of OpenFF supported</span>
                    <span class="c1"># file objects in &quot;t&quot;ext mode, but not file objects</span>
                    <span class="c1"># in &quot;b&quot;inary mode. Now we expect all input file objects</span>
                    <span class="c1"># to handle binary mode, but don&#39;t want to break older code.</span>
                    <span class="n">tmpfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
                <span class="n">tmpfile</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span>
                    <span class="n">tmpfile</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s2">&quot;SMI&quot;</span><span class="p">,</span>
                    <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
                    <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;PDB&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoleculeParseError</span><span class="p">(</span>
                <span class="s2">&quot;RDKit can not safely read PDBs on their own. Information about bond order and aromaticity &quot;</span>
                <span class="s2">&quot;is likely to be lost. To read a PDB using RDKit use Molecule.from_pdb_and_smiles()&quot;</span>
            <span class="p">)</span>
            <span class="c1"># TODO: See if we can implement PDB+mol/smi combinations to get complete bond information.</span>
            <span class="c1"># https://github.com/openforcefield/openff-toolkit/issues/121</span>
            <span class="c1"># file_data = file_obj.read()</span>
            <span class="c1"># rdmol = Chem.MolFromPDBBlock(file_data)</span>
            <span class="c1"># mol = Molecule.from_rdkit(rdmol, _cls=_cls)</span>
            <span class="c1"># mols.append(mol)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported file format: </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: TDT file support</span>
        <span class="k">return</span> <span class="n">mols</span>

    <span class="k">def</span> <span class="nf">to_file_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">file_obj</span><span class="p">,</span> <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes an OpenFF Molecule to a file-like object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule to write</span>
<span class="sd">        file_obj</span>
<span class="sd">            The file-like object to write to</span>
<span class="sd">        file_format</span>
<span class="sd">            The format for writing the molecule data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">_TOOLKIT_WRITERS</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;SDF&quot;</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDWriter</span><span class="p">,</span>
            <span class="s2">&quot;MOL&quot;</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SDWriter</span><span class="p">,</span>
            <span class="s2">&quot;PDB&quot;</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">PDBWriter</span><span class="p">,</span>
            <span class="s2">&quot;TDT&quot;</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">TDTWriter</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">file_format</span> <span class="o">=</span> <span class="n">normalize_file_format</span><span class="p">(</span><span class="n">file_format</span><span class="p">)</span>
        <span class="n">_require_text_file_obj</span><span class="p">(</span><span class="n">file_obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;SMI&quot;</span><span class="p">:</span>
            <span class="c1"># Special case for SMILES</span>
            <span class="n">smiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_smiles</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">smiles</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_line</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">smiles</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">file_obj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_line</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">writer_func</span> <span class="o">=</span> <span class="n">_TOOLKIT_WRITERS</span><span class="p">[</span><span class="n">file_format</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported file format: </span><span class="si">{</span><span class="n">file_format</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
            <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">writer_func</span><span class="p">(</span><span class="n">file_obj</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file_format</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes an OpenFF Molecule to a file-like object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule to write</span>
<span class="sd">        file_path</span>
<span class="sd">            The file path to write to</span>
<span class="sd">        file_format</span>
<span class="sd">            The format for writing the molecule data</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># open a file object and pass to the object writer</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_obj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_file_obj</span><span class="p">(</span>
                <span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">,</span> <span class="n">file_obj</span><span class="o">=</span><span class="n">file_obj</span><span class="p">,</span> <span class="n">file_format</span><span class="o">=</span><span class="n">file_format</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">enumerate_stereoisomers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">undefined_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_isomers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">rationalise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Molecule&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the stereocenters and bonds of the current molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule whose state we should enumerate</span>

<span class="sd">        undefined_only</span>
<span class="sd">            If we should enumerate all stereocenters and bonds or only those with undefined stereochemistry</span>

<span class="sd">        max_isomers</span>
<span class="sd">            The maximum amount of molecules that should be returned</span>

<span class="sd">        rationalise</span>
<span class="sd">            If we should try to build and rationalise the molecule to ensure it can exist</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        molecules</span>
<span class="sd">            A list of openff.toolkit.topology.Molecule instances</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem.EnumerateStereoisomers</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[import-untyped]</span>
            <span class="n">EnumerateStereoisomers</span><span class="p">,</span>
            <span class="n">StereoEnumerationOptions</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># create the molecule</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="o">=</span><span class="n">molecule</span><span class="p">)</span>

        <span class="c1"># in case any bonds/centers are missing stereo chem flag it here</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flagPossibleStereoCenters</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">FindPotentialStereoBonds</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># set up the options</span>
        <span class="n">stereo_opts</span> <span class="o">=</span> <span class="n">StereoEnumerationOptions</span><span class="p">(</span>
            <span class="n">tryEmbedding</span><span class="o">=</span><span class="n">rationalise</span><span class="p">,</span>
            <span class="n">onlyUnassigned</span><span class="o">=</span><span class="n">undefined_only</span><span class="p">,</span>
            <span class="n">maxIsomers</span><span class="o">=</span><span class="n">max_isomers</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">isomers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">EnumerateStereoisomers</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">stereo_opts</span><span class="p">))</span>

        <span class="n">molecules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">isomer</span> <span class="ow">in</span> <span class="n">isomers</span><span class="p">:</span>
            <span class="c1"># isomer has CIS/TRANS tags so convert back to E/Z</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SetDoubleBondNeighborDirections</span><span class="p">(</span><span class="n">isomer</span><span class="p">)</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">isomer</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span><span class="n">isomer</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mol</span> <span class="o">!=</span> <span class="n">molecule</span><span class="p">:</span>
                <span class="n">molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span>

    <span class="k">def</span> <span class="nf">enumerate_tautomers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">max_states</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;Molecule&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enumerate the possible tautomers of the current molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule whose state we should enumerate</span>

<span class="sd">        max_states</span>
<span class="sd">            The maximum amount of molecules that should be returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecules</span>
<span class="sd">            A list of openff.toolkit.topology.Molecule instances not including the input molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem.MolStandardize</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[import-untyped]</span>
            <span class="n">rdMolStandardize</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">enumerator</span> <span class="o">=</span> <span class="n">rdMolStandardize</span><span class="o">.</span><span class="n">TautomerEnumerator</span><span class="p">()</span>
        <span class="n">enumerator</span><span class="o">.</span><span class="n">SetMaxTautomers</span><span class="p">(</span><span class="n">max_states</span><span class="p">)</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">())</span>

        <span class="n">tautomers</span> <span class="o">=</span> <span class="n">enumerator</span><span class="o">.</span><span class="n">Enumerate</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># make a list of OpenFF molecules excluding the input molecule</span>
        <span class="n">molecules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">taut</span> <span class="ow">in</span> <span class="n">tautomers</span><span class="p">:</span>
            <span class="n">taut_hs</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">taut</span><span class="p">)</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_smiles</span><span class="p">(</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">taut_hs</span><span class="p">),</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">mol</span> <span class="o">!=</span> <span class="n">molecule</span><span class="p">:</span>
                <span class="n">molecules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">molecules</span><span class="p">[:</span><span class="n">max_states</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">canonical_order_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Canonical order the atoms in the molecule using the RDKit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The input molecule</span>

<span class="sd">         Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule</span>
<span class="sd">            The input molecule, with canonically-indexed atoms and bonds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>

        <span class="c1"># get the canonical ordering with hydrogens first</span>
        <span class="c1"># this is the default behaviour of RDKit</span>
        <span class="n">atom_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">CanonicalRankAtoms</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">breakTies</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">heavy_atoms</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetNumHeavyAtoms</span><span class="p">()</span>
        <span class="n">hydrogens</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()</span> <span class="o">-</span> <span class="n">heavy_atoms</span>

        <span class="c1"># now go through and change the rankings to get the heavy atoms first if hydrogens are present</span>
        <span class="k">if</span> <span class="n">hydrogens</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atom_order</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">atom_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">hydrogens</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">atom_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">heavy_atoms</span>

        <span class="c1"># make an atom mapping from the atom_order and remap the molecule</span>
        <span class="n">atom_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_order</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">molecule</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">atom_mapping</span><span class="p">,</span> <span class="n">current_to_new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_smiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">isomeric</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">explicit_hydrogens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mapped</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the RDKit toolkit to convert a Molecule into a SMILES string.</span>
<span class="sd">        A partially mapped smiles can also be generated for atoms of interest by supplying</span>
<span class="sd">        an `atom_map` to the properties dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule to convert into a SMILES.</span>
<span class="sd">        isomeric</span>
<span class="sd">            return an isomeric smiles</span>
<span class="sd">        explicit_hydrogens</span>
<span class="sd">            return a smiles string containing all hydrogens explicitly</span>
<span class="sd">        mapped</span>
<span class="sd">            return a explicit hydrogen mapped smiles, the atoms to be mapped can be controlled by</span>
<span class="sd">            supplying an atom map into the properties dictionary. If no mapping is passed all</span>
<span class="sd">            atoms will be mapped in order, else an atom map dictionary from the current atom</span>
<span class="sd">            index to the map id should be supplied with no duplicates. The map ids (values) should</span>
<span class="sd">            start from 0 or 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smiles</span>
<span class="sd">            The SMILES of the input molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">explicit_hydrogens</span><span class="p">:</span>
            <span class="c1"># remove the hydrogens from the molecule</span>
            <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mapped</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">explicit_hydrogens</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Mapped smiles require all hydrogens and &quot;</span>
                <span class="s2">&quot;stereochemistry to be defined to retain order&quot;</span>
            <span class="p">)</span>

            <span class="c1"># if we only want to map specific atoms check for an atom map</span>
            <span class="n">atom_map</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atom_map&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># make sure there are no repeated indices</span>
                <span class="n">map_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atom_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_ids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_map</span><span class="p">):</span>
                    <span class="n">atom_map</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">atom_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="c1"># we need to increment the map index</span>
                    <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="nb">map</span> <span class="ow">in</span> <span class="n">atom_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">atom_map</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">atom_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># now we need to add the indexing to the rdmol to get it in the smiles</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
                    <span class="c1"># the mapping must start from 1, as RDKit uses 0 to represent no mapping.</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">SetAtomMapNum</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># try to set the atom map</span>
                        <span class="n">map_idx</span> <span class="o">=</span> <span class="n">atom_map</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()]</span>
                        <span class="n">atom</span><span class="o">.</span><span class="n">SetAtomMapNum</span><span class="p">(</span><span class="n">map_idx</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">continue</span>

        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="n">isomeric</span><span class="p">,</span> <span class="n">allHsExplicit</span><span class="o">=</span><span class="n">explicit_hydrogens</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_smiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">hydrogens_are_explicit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from a SMILES string using the RDKit toolkit.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smiles</span>
<span class="sd">            The SMILES string to turn into a molecule</span>
<span class="sd">        hydrogens_are_explicit</span>
<span class="sd">            If False, RDKit will perform hydrogen addition using Chem.AddHs</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            Whether to accept SMILES with undefined stereochemistry. If False,</span>
<span class="sd">            an exception will be raised if a SMILES with undefined stereochemistry</span>
<span class="sd">            is passed into this function.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>
<span class="sd">        name</span>
<span class="sd">            An optional name to pass to the _cls constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule</span>
<span class="sd">            An OpenFF style molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RadicalsNotSupportedError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rdmol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SMILESParseError</span><span class="p">(</span><span class="s2">&quot;Unable to parse the SMILES string&quot;</span><span class="p">)</span>

        <span class="c1"># strip the atom map from the molecule if it has one</span>
        <span class="c1"># so we don&#39;t affect the sterochemistry tags</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># set the map back to zero but hide the index in the atom prop data</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s2">&quot;_map_idx&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()))</span>
                <span class="c1"># set it back to zero</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetAtomMapNum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Chem.SanitizeMol calls updatePropertyCache so we don&#39;t need to call it ourselves</span>
        <span class="c1"># https://www.rdkit.org/docs/cppapi/namespaceRDKit_1_1MolOps.html#a8d831787aaf2d65d9920c37b25b476f5</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_SETAROMATICITY</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>

        <span class="c1"># Chem.MolFromSmiles adds bond directions (i.e. ENDDOWNRIGHT/ENDUPRIGHT), but</span>
        <span class="c1"># doesn&#39;t set bond.GetStereo(). We need to call AssignStereochemistry for that.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># Throw an exception/warning if there is unspecified stereochemistry.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_undefined_stereo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detect_undefined_stereo</span><span class="p">(</span>
                <span class="n">rdmol</span><span class="p">,</span>
                <span class="n">err_msg_prefix</span><span class="o">=</span><span class="s2">&quot;Unable to make OFFMol from SMILES: &quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Add explicit hydrogens if they aren&#39;t there already</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hydrogens_are_explicit</span><span class="p">:</span>
            <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">hydrogens_are_explicit</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()):</span>
                <span class="n">atom</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNumImplicitHs</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;hydrogens_are_explicit&#39; was specified as True, but RDKit toolkit interpreted &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;SMILES &#39;</span><span class="si">{</span><span class="n">smiles</span><span class="si">}</span><span class="s2">&#39; as having implicit hydrogen. If this SMILES is intended to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;express all explicit hydrogens in the molecule, then you should construct the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;desired molecule as an RDMol with no implicit hydrogens, and then use &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Molecule.from_rdkit() to create the desired OFFMol.&quot;</span>
                    <span class="p">)</span>

        <span class="n">molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span><span class="p">,</span>
            <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span>
            <span class="n">hydrogens_are_explicit</span><span class="o">=</span><span class="n">hydrogens_are_explicit</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">from_inchi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inchi</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a Molecule from a InChI representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inchi</span>
<span class="sd">            The InChI representation of the molecule.</span>

<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            Whether to accept InChI with undefined stereochemistry. If False,</span>
<span class="sd">            an exception will be raised if a InChI with undefined stereochemistry</span>
<span class="sd">            is passed into this function.</span>

<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="c1"># this seems to always remove the hydrogens</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromInchi</span><span class="p">(</span><span class="n">inchi</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">removeHs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># try and catch an InChI parsing error</span>
        <span class="k">if</span> <span class="n">rdmol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InChIParseError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;There was an issue parsing the InChI string (</span><span class="si">{</span><span class="n">inchi</span><span class="si">}</span><span class="s2">), please check and try again.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># process the molecule</span>
        <span class="c1"># TODO do we need this with inchi?</span>
        <span class="n">rdmol</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_SETAROMATICITY</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>

        <span class="c1"># add hydrogens back here</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="n">molecule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="n">allow_undefined_stereo</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="n">_cls</span>
        <span class="p">)</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">return</span> <span class="n">molecule</span>

    <span class="k">def</span> <span class="nf">generate_conformers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">n_conformers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">rms_cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Quantity</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clear_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">make_carboxylic_acids_cis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate molecule conformers using RDKit.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        .. todo ::</span>

<span class="sd">           * which parameters should we expose? (or can we implement a general system with \*\*kwargs?)</span>
<span class="sd">           * will the coordinates be returned in the OpenFF Molecule&#39;s own indexing system?</span>
<span class="sd">               Or is there a chance that they&#39;ll get reindexed when we convert the input into an RDMol?</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule to generate conformers for.</span>
<span class="sd">        n_conformers</span>
<span class="sd">            Maximum number of conformers to generate.</span>
<span class="sd">        rms_cutoff</span>
<span class="sd">            The minimum RMS value at which two conformers are considered redundant and one is deleted.</span>
<span class="sd">            If None, the cutoff is set to 1 Angstrom</span>

<span class="sd">        clear_existing</span>
<span class="sd">            Whether to overwrite existing conformers for the molecule.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>
<span class="sd">        make_carboxylic_acids_cis</span>
<span class="sd">            Guarantee all conformers have exclusively cis carboxylic acid groups (COOH)</span>
<span class="sd">            by rotating the proton in any trans carboxylic acids 180 degrees around the C-O bond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>

        <span class="k">if</span> <span class="n">rms_cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rms_cutoff</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
        <span class="c1"># TODO: This generates way more conformations than omega, given the same</span>
        <span class="c1"># nConfs and RMS threshold. Is there some way to set an energy cutoff as well?</span>
        <span class="n">first_conformer_generation_status</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMultipleConfs</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">numConfs</span><span class="o">=</span><span class="n">n_conformers</span><span class="p">,</span>
            <span class="n">pruneRmsThresh</span><span class="o">=</span><span class="n">rms_cutoff</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">),</span>
            <span class="n">randomSeed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="c1"># params=AllChem.ETKDG()</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">first_conformer_generation_status</span><span class="p">:</span>
            <span class="c1"># For some large molecules, conformer generation fails without `useRandomCoords`;</span>
            <span class="c1"># Landrum recommends it https://github.com/rdkit/rdkit/issues/3764#issuecomment-769367489</span>
            <span class="n">fallback_conformer_generation_status</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMultipleConfs</span><span class="p">(</span>
                <span class="n">rdmol</span><span class="p">,</span>
                <span class="n">numConfs</span><span class="o">=</span><span class="n">n_conformers</span><span class="p">,</span>
                <span class="n">pruneRmsThresh</span><span class="o">=</span><span class="n">rms_cutoff</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">),</span>
                <span class="n">randomSeed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">useRandomCoords</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">fallback_conformer_generation_status</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConformerGenerationError</span><span class="p">(</span><span class="s2">&quot;RDKit conformer generation failed.&quot;</span><span class="p">)</span>

        <span class="n">molecule2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_rdkit</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span> <span class="n">allow_undefined_stereo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_cls</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">clear_existing</span><span class="p">:</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">molecule2</span><span class="o">.</span><span class="n">_conformers</span><span class="p">:</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">make_carboxylic_acids_cis</span><span class="p">:</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">_make_carboxylic_acids_cis</span><span class="p">(</span><span class="n">toolkit_registry</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign_partial_charges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">partial_charge_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_conformers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Quantity</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">strict_n_conformers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize_partial_charges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute partial charges with RDKit, and assign</span>
<span class="sd">        the new values to the partial_charges attribute.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            Molecule for which partial charges are to be computed</span>
<span class="sd">        partial_charge_method</span>
<span class="sd">            The charge model to use. One of [&#39;mmff94&#39;, &#39;gasteiger&#39;]. If None, &#39;mmff94&#39; will be used.</span>

<span class="sd">            * &#39;mmff94&#39;: Applies partial charges using the Merck Molecular Force Field</span>
<span class="sd">                        (MMFF). This method does not make use of conformers, and hence</span>
<span class="sd">                        ``use_conformers`` and ``strict_n_conformers`` will not impact</span>
<span class="sd">                        the partial charges produced.</span>
<span class="sd">        use_conformers</span>
<span class="sd">            shape (n_atoms, 3) and dimension of distance. Optional, default = None</span>
<span class="sd">            Coordinates to use for partial charge calculation. If None, an appropriate number of</span>
<span class="sd">            conformers will be generated.</span>
<span class="sd">        strict_n_conformers</span>
<span class="sd">            Whether to raise an exception if an invalid number of conformers is provided for</span>
<span class="sd">            the given charge method.</span>
<span class="sd">            If this is False and an invalid number of conformers is found, a warning will be raised.</span>
<span class="sd">        normalize_partial_charges</span>
<span class="sd">            Whether to offset partial charges so that they sum to the total formal charge of the molecule.</span>
<span class="sd">            This is used to prevent accumulation of rounding errors when the partial charge generation method has</span>
<span class="sd">            low precision.</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ChargeMethodUnavailableError if the requested charge method can not be handled by this toolkit</span>

<span class="sd">        ChargeCalculationError if the charge method is supported by this toolkit, but fails</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>

        <span class="k">if</span> <span class="n">partial_charge_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">partial_charge_method</span> <span class="o">=</span> <span class="s2">&quot;mmff94&quot;</span>

        <span class="n">partial_charge_method</span> <span class="o">=</span> <span class="n">partial_charge_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">partial_charge_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_supported_charge_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ChargeMethodUnavailableError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;partial_charge_method &#39;</span><span class="si">{</span><span class="n">partial_charge_method</span><span class="si">}</span><span class="s2">&#39; is not available from RDKitToolkitWrapper. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available charge methods are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_supported_charge_methods</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">rdkit_molecule</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">partial_charge_method</span> <span class="o">==</span> <span class="s2">&quot;mmff94&quot;</span><span class="p">:</span>
            <span class="n">mmff_properties</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">MMFFGetMoleculeProperties</span><span class="p">(</span>
                <span class="n">rdkit_molecule</span><span class="p">,</span> <span class="s2">&quot;MMFF94&quot;</span>
            <span class="p">)</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">mmff_properties</span><span class="o">.</span><span class="n">GetMMFFPartialCharge</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">partial_charge_method</span> <span class="o">==</span> <span class="s2">&quot;gasteiger&quot;</span><span class="p">:</span>
            <span class="n">AllChem</span><span class="o">.</span><span class="n">ComputeGasteigerCharges</span><span class="p">(</span><span class="n">rdkit_molecule</span><span class="p">)</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">rdatom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_GasteigerCharge&quot;</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">rdatom</span> <span class="ow">in</span> <span class="n">rdkit_molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span>
            <span class="p">]</span>

        <span class="n">molecule</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">charges</span><span class="p">),</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize_partial_charges</span><span class="p">:</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">_normalize_partial_charges</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_elf_is_problematic_conformer</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">conformer</span><span class="p">:</span> <span class="n">Quantity</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A function which checks if a particular conformer is known to be problematic</span>
<span class="sd">        when computing ELF partial charges.</span>

<span class="sd">        Currently this includes conformers which:</span>

<span class="sd">        * contain a trans-COOH configuration. The trans conformer is discarded because</span>
<span class="sd">          it leads to strong electrostatic interactions when assigning charges, and these</span>
<span class="sd">          result in unreasonable charges. Downstream calculations have observed up to a</span>
<span class="sd">          4 log unit error in water-octanol logP calculations when using charges assigned</span>
<span class="sd">          from trans conformers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            A tuple of a bool stating whether the conformer is problematic and, if it</span>
<span class="sd">            is, a string message explaing why. If the conformer is not problematic, the</span>
<span class="sd">            second return value will be none.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem.rdMolTransforms</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[import-untyped]</span>
            <span class="n">GetDihedralRad</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create a copy of the molecule which contains only this conformer.</span>
        <span class="n">molecule_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
        <span class="n">molecule_copy</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="p">[</span><span class="n">conformer</span><span class="p">]</span>

        <span class="n">rdkit_molecule</span> <span class="o">=</span> <span class="n">molecule_copy</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>

        <span class="c1"># Check for trans-COOH configurations</span>
        <span class="n">carboxylic_acid_matches</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_find_smarts_matches</span><span class="p">(</span>
            <span class="n">rdkit_molecule</span><span class="p">,</span> <span class="s2">&quot;[#6X3:2](=[#8:1])(-[#8X2H1:3]-[#1:4])&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">carboxylic_acid_matches</span><span class="p">:</span>
            <span class="n">dihedral_angle</span> <span class="o">=</span> <span class="n">GetDihedralRad</span><span class="p">(</span><span class="n">rdkit_molecule</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">match</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dihedral_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">:</span>
                <span class="c1"># Discard the &#39;trans&#39; conformer.</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="s2">&quot;Molecules which contain COOH functional groups in a trans &quot;</span>
                    <span class="s2">&quot;configuration are discarded by the ELF method.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_elf_prune_problematic_conformers</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Quantity</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A function which attempts to remove conformers which are known to be</span>
<span class="sd">        problematic when computing ELF partial charges.</span>

<span class="sd">        Currently this includes conformers which:</span>

<span class="sd">        * contain a trans-COOH configuration. These conformers ... TODO add reason.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * Problematic conformers are flagged by the</span>
<span class="sd">          ``RDKitToolkitWrapper._elf_is_problematic_conformer`` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The conformers to retain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">valid_conformers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">conformers</span><span class="p">):</span>
            <span class="n">is_problematic</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_elf_is_problematic_conformer</span><span class="p">(</span>
                <span class="n">molecule</span><span class="p">,</span> <span class="n">conformer</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">is_problematic</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Discarding conformer </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_conformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">valid_conformers</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_elf_compute_electrostatic_energy</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">conformer</span><span class="p">:</span> <span class="n">Quantity</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the &#39;electrostatic interaction energy&#39; of a particular conformer</span>
<span class="sd">        of a molecule.</span>

<span class="sd">        The energy is computed as the sum of ``|q_i * q_j| * r_ij^-1`` over all pairs</span>
<span class="sd">        of atoms (i, j) excluding 1-2 and 1-3 terms, where q_i is the partial charge</span>
<span class="sd">        of atom i and r_ij the Euclidean distance between atoms i and j.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The partial charges will be taken from the molecule directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule containing the partial charges.</span>
<span class="sd">        conformer</span>
<span class="sd">            The conformer to compute the energy of. This should be a unit wrapped</span>
<span class="sd">            numpy array with shape=(n_atoms, 3) with units compatible with angstroms.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The electrostatic interaction energy in units of [e^2 / Angstrom].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">molecule</span><span class="o">.</span><span class="n">partial_charges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The molecule has no partial charges assigned.&quot;</span><span class="p">)</span>

        <span class="n">partial_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">partial_charges</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Build an exclusion list for 1-2 and 1-3 interactions.</span>
        <span class="n">excluded_x</span><span class="p">,</span> <span class="n">excluded_y</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="p">{</span>
                <span class="o">*</span><span class="p">[(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">)</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">],</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span> <span class="n">angle</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">angles</span>
                <span class="p">],</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># Build the distance matrix between all pairs of atoms.</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">conformer</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>

        <span class="c1"># Equation 1: (a - b)^2 = a^2 - 2ab + b^2</span>
        <span class="c1"># distances_squared will eventually wind up as the squared distances</span>
        <span class="c1"># although it is first computed as the ab portion of Eq 1</span>
        <span class="n">distances_squared</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># np.einsum is both faster than np.diag, and not read-only</span>
        <span class="c1"># we know that a^2 == b^2 == diag(ab)</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ii-&gt;i&quot;</span><span class="p">,</span> <span class="n">distances_squared</span><span class="p">)</span>
        <span class="c1"># we modify in-place so we can use the `diag` view</span>
        <span class="c1"># to make the diagonals 0</span>
        <span class="n">distances_squared</span> <span class="o">+=</span> <span class="n">distances_squared</span> <span class="o">-</span> <span class="n">diag</span> <span class="o">-</span> <span class="n">diag</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Handle edge cases where the squared distance is slightly negative due to</span>
        <span class="c1"># precision issues</span>
        <span class="n">diag</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.0</span>  <span class="c1"># this is somewhat faster than np.fill_diagonal</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">distances_squared</span><span class="p">)</span>

        <span class="n">inverse_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span> <span class="n">where</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Multiply by the charge products.</span>
        <span class="n">charge_products</span> <span class="o">=</span> <span class="n">partial_charges</span> <span class="o">@</span> <span class="n">partial_charges</span><span class="o">.</span><span class="n">T</span>

        <span class="n">charge_products</span><span class="p">[</span><span class="n">excluded_x</span><span class="p">,</span> <span class="n">excluded_y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">charge_products</span><span class="p">[</span><span class="n">excluded_y</span><span class="p">,</span> <span class="n">excluded_x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">interaction_energies</span> <span class="o">=</span> <span class="n">inverse_distances</span> <span class="o">*</span> <span class="n">charge_products</span>

        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">interaction_energies</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_elf_compute_rms_matrix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes the symmetric RMS matrix of all conformers in a molecule taking</span>
<span class="sd">        only heavy atoms into account.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule containing the conformers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The RMS matrix with shape=(n_conformers, n_conformers).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>

        <span class="n">rdkit_molecule</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">())</span>

        <span class="n">n_conformers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">conformers</span><span class="p">)</span>

        <span class="c1"># rdkit does not have conformer indices but conformer &quot;ids&quot;</span>
        <span class="n">conformer_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">conf</span><span class="o">.</span><span class="n">GetId</span><span class="p">()</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">rdkit_molecule</span><span class="o">.</span><span class="n">GetConformers</span><span class="p">()]</span>

        <span class="c1"># Compute the RMS matrix making sure to take into account any automorhism (e.g</span>
        <span class="c1"># a phenyl or nitro substituent flipped 180 degrees.</span>
        <span class="n">rms_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_conformers</span><span class="p">,</span> <span class="n">n_conformers</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_conformers</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">rms_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetBestRMS</span><span class="p">(</span>
                <span class="n">rdkit_molecule</span><span class="p">,</span>
                <span class="n">rdkit_molecule</span><span class="p">,</span>
                <span class="n">conformer_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">conformer_ids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">rms_matrix</span> <span class="o">+=</span> <span class="n">rms_matrix</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">rms_matrix</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_elf_select_diverse_conformers</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">ranked_conformers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">rms_tolerance</span><span class="p">:</span> <span class="n">Quantity</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Quantity</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attempt to greedily select a specified number conformers which are maximally</span>
<span class="sd">        diverse.</span>

<span class="sd">        The conformer with the lowest electrostatic energy (the first conformer in the</span>
<span class="sd">        ``ranked_conformers`` list) is always chosen. After that selection proceeds by:</span>

<span class="sd">        a) selecting an un-selected conformer which is the most different from those</span>
<span class="sd">          already selected, and whose RMS compared to each selected conformer is</span>
<span class="sd">          greater than ``rms_tolerance``. Here most different means the conformer</span>
<span class="sd">          which has the largest sum of RMS with the selected conformers.</span>

<span class="sd">        b) repeating a) until either ``limit`` number of conformers have been selected,</span>
<span class="sd">           or there are no more distinct conformers to select from.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        * As the selection is greedy there is no guarantee that the selected conformers</span>
<span class="sd">          will be the optimal distinct i.e. there may be other selections of conformers</span>
<span class="sd">          which are more distinct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule object which matches the conformers to select from.</span>
<span class="sd">        ranked_conformers</span>
<span class="sd">            A list of conformers to select from, ranked by their electrostatic</span>
<span class="sd">            interaction energy (see ``_compute_electrostatic_energy``).</span>
<span class="sd">        limit</span>
<span class="sd">            The maximum number of conformers to select.</span>
<span class="sd">        rms_tolerance</span>
<span class="sd">            Conformers whose RMS is within this amount will be treated as identical and</span>
<span class="sd">            the duplicate discarded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The select list of conformers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute the RMS between all pairs of conformers</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">conformers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">ranked_conformers</span><span class="p">:</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">add_conformer</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>

        <span class="n">rms_matrix</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_elf_compute_rms_matrix</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>

        <span class="c1"># Apply the greedy selection process.</span>
        <span class="n">selected_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">angstrom_tol</span> <span class="o">=</span> <span class="n">rms_tolerance</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">molecule</span><span class="o">.</span><span class="n">n_conformers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">selected_rms</span> <span class="o">=</span> <span class="n">rms_matrix</span><span class="p">[</span><span class="n">selected_indices</span><span class="p">]</span>
            <span class="n">any_too_close</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">selected_rms</span> <span class="o">&lt;</span> <span class="n">angstrom_tol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">any_too_close</span><span class="p">):</span>
                <span class="c1"># stop if all conformers remaining are within RMS</span>
                <span class="c1"># threshold of any selected conformer</span>
                <span class="k">break</span>

            <span class="c1"># add the next conformer with the largest summed RMS distance</span>
            <span class="c1"># to current selected conformers</span>
            <span class="n">rmsdist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">any_too_close</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">selected_rms</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">selected_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">rmsdist</span><span class="o">.</span><span class="n">argmax</span><span class="p">()))</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">ranked_conformers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">apply_elf_conformer_selection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">percentage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">rms_tolerance</span><span class="p">:</span> <span class="n">Quantity</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies the `ELF method</span>
<span class="sd">        &lt;https://docs.eyesopen.com/toolkits/python/quacpactk/molchargetheory.html#elf-conformer-selection&gt;`_</span>
<span class="sd">        to select a set of diverse conformers which have minimal electrostatically</span>
<span class="sd">        strongly interacting functional groups from a molecules conformers.</span>

<span class="sd">        The diverse conformer selection is performed by the ``_elf_select_diverse_conformers``</span>
<span class="sd">        function, which attempts to greedily select conformers which are most distinct</span>
<span class="sd">        according to their RMS.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        * Although this function is inspired by the OpenEye ELF10 method, this</span>
<span class="sd">          implementation may yield slightly different conformers due to potential</span>
<span class="sd">          differences in this and the OE closed source implementation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The input molecule should have a large set of conformers already</span>
<span class="sd">          generated to select the ELF10 conformers from.</span>
<span class="sd">        * The selected conformers will be retained in the `molecule.conformers` list</span>
<span class="sd">          while unselected conformers will be discarded.</span>
<span class="sd">        * Only heavy atoms are included when using the RMS to select diverse conformers.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        RDKitToolkitWrapper._elf_select_diverse_conformers</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule which contains the set of conformers to select from.</span>
<span class="sd">        percentage</span>
<span class="sd">            The percentage of conformers with the lowest electrostatic interaction</span>
<span class="sd">            energies to greedily select from.</span>
<span class="sd">        limit</span>
<span class="sd">            The maximum number of conformers to select.</span>
<span class="sd">        rms_tolerance</span>
<span class="sd">            Conformers whose RMS is within this amount will be treated as identical and</span>
<span class="sd">            the duplicate discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">molecule</span><span class="o">.</span><span class="n">n_conformers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Copy the input molecule so we can directly perturb it within the method.</span>
        <span class="n">molecule_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>

        <span class="c1"># Prune any problematic conformers, such as trans-COOH configurations.</span>
        <span class="n">conformers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elf_prune_problematic_conformers</span><span class="p">(</span><span class="n">molecule_copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There were no conformers to select from after discarding conformers &quot;</span>
                <span class="s2">&quot;which are known to be problematic when computing ELF partial charges. &quot;</span>
                <span class="s2">&quot;Make sure to generate a diverse array of conformers before calling the &quot;</span>
                <span class="s2">&quot;`RDKitToolkitWrapper.apply_elf_conformer_selection` method.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Generate a set of absolute MMFF94 partial charges for the molecule and use</span>
        <span class="c1"># these to compute the electrostatic interaction energy of each conformer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_partial_charges</span><span class="p">(</span><span class="n">molecule_copy</span><span class="p">,</span> <span class="s2">&quot;mmff94&quot;</span><span class="p">)</span>

        <span class="n">conformer_energies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_elf_compute_electrostatic_energy</span><span class="p">(</span><span class="n">molecule_copy</span><span class="p">,</span> <span class="n">conformer</span><span class="p">),</span>
                <span class="n">conformer</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">conformers</span>
        <span class="p">]</span>

        <span class="c1"># Rank the conformer energies and retain `percentage`% with the lowest energies.</span>
        <span class="n">conformer_energies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">conformer_energies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cutoff_index</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conformer_energies</span><span class="p">)</span> <span class="o">*</span> <span class="n">percentage</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span>

        <span class="n">low_energy_conformers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">conformer</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">conformer_energies</span><span class="p">[:</span><span class="n">cutoff_index</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="c1"># Attempt to greedily select `limit` conformers which are maximally diverse.</span>
        <span class="n">diverse_conformers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elf_select_diverse_conformers</span><span class="p">(</span>
            <span class="n">molecule_copy</span><span class="p">,</span> <span class="n">low_energy_conformers</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">rms_tolerance</span>
        <span class="p">)</span>

        <span class="n">molecule</span><span class="o">.</span><span class="n">_conformers</span> <span class="o">=</span> <span class="n">diverse_conformers</span>

    <span class="k">def</span> <span class="nf">from_rdkit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rdmol</span><span class="p">,</span>
        <span class="n">allow_undefined_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">hydrogens_are_explicit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Molecule from an RDKit molecule.</span>

<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol</span>
<span class="sd">            An RDKit molecule</span>
<span class="sd">        allow_undefined_stereo</span>
<span class="sd">            If false, raises an exception if rdmol contains undefined stereochemistry.</span>
<span class="sd">        hydrogens_are_explicit</span>
<span class="sd">            If False, RDKit will perform hydrogen addition using Chem.AddHs</span>
<span class="sd">        _cls</span>
<span class="sd">            Molecule constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        molecule</span>
<span class="sd">            An OpenFF molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Create a molecule from an RDKit molecule</span>

<span class="sd">        &gt;&gt;&gt; from rdkit import Chem</span>
<span class="sd">        &gt;&gt;&gt; from openff.toolkit._tests.utils import get_data_file_path</span>
<span class="sd">        &gt;&gt;&gt; rdmol = Chem.MolFromMolFile(get_data_file_path(&#39;systems/monomers/ethanol.sdf&#39;))</span>

<span class="sd">        &gt;&gt;&gt; toolkit_wrapper = RDKitToolkitWrapper()</span>
<span class="sd">        &gt;&gt;&gt; molecule = toolkit_wrapper.from_rdkit(rdmol)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
        <span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AllChem</span>

        <span class="k">if</span> <span class="n">_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">openff.toolkit.topology.molecule</span> <span class="kn">import</span> <span class="n">Molecule</span>

            <span class="n">_cls</span> <span class="o">=</span> <span class="n">Molecule</span>

        <span class="c1"># Make a copy of the RDKit Mol as we&#39;ll need to change it (e.g. assign stereo).</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="n">frags</span> <span class="o">=</span> <span class="n">AllChem</span><span class="o">.</span><span class="n">GetMolFrags</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;RDKit Molecule passed to from_rdkit consists of more than one molecule, consider running &quot;</span>
                          <span class="s2">&quot;rdkit.Chem.AllChem.GetMolfrags(rdmol, asMols=True) or splitting input SMILES at &#39;.&#39; to get &quot;</span>
                          <span class="s2">&quot;separate molecules and pass them to from_rdkit one at a time. While this is supported for &quot;</span>
                          <span class="s2">&quot;legacy reasons, OpenFF Molecule objects are not supposed to contain disconnected chemical &quot;</span>
                          <span class="s2">&quot;graphs and this may result in undefined behavior later on. The OpenFF ecosystem is built &quot;</span>
                          <span class="s2">&quot;to handle multiple molecules, but they should be in a Topology object, ex: &quot;</span>
                          <span class="s2">&quot;top = Topology.from_molecules([mol1, mol2])&quot;</span><span class="p">,</span>
                          <span class="n">MultipleComponentsInMoleculeWarning</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
                          <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hydrogens_are_explicit</span><span class="p">:</span>
            <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">addCoords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Sanitizing the molecule. We handle aromaticity and chirality manually.</span>
        <span class="c1"># This SanitizeMol(...) calls cleanUp, updatePropertyCache, symmetrizeSSSR,</span>
        <span class="c1"># assignRadicals, setConjugation, and setHybridization.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span>
                <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_SETAROMATICITY</span>
                <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span>
                <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_CLEANUPCHIRALITY</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>
        <span class="c1"># SetAromaticity set aromatic bonds to 1.5, but Molecule.bond_order is an</span>
        <span class="c1"># integer (contrarily to fractional_bond_order) so we need the Kekule order.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">Kekulize</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># Make sure the bond stereo tags are set before checking for</span>
        <span class="c1"># undefined stereo. RDKit can figure out bond stereo from other</span>
        <span class="c1"># information in the Mol object like bond direction properties.</span>
        <span class="c1"># Do not overwrite eventual chiral tags provided by the user.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Check for undefined stereochemistry.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_undefined_stereo</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detect_undefined_stereo</span><span class="p">(</span>
                <span class="n">rdmol</span><span class="p">,</span>
                <span class="n">err_msg_prefix</span><span class="o">=</span><span class="s2">&quot;Unable to make OFFMol from RDMol: &quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Create a new OpenFF Molecule</span>
        <span class="n">offmol</span> <span class="o">=</span> <span class="n">_cls</span><span class="p">()</span>

        <span class="c1"># If RDMol has a title, use it</span>
        <span class="k">if</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">):</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">)</span>

        <span class="c1"># Store all properties</span>
        <span class="c1"># TODO: Should there be an API point for storing properties?</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetPropsAsDict</span><span class="p">()</span>
        <span class="n">offmol</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="n">properties</span>

        <span class="c1"># setting chirality in openeye requires using neighbor atoms</span>
        <span class="c1"># therefore we can&#39;t do it until after the atoms and bonds are all added</span>
        <span class="n">map_atoms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">map_bonds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># if we are loading from a mapped smiles extract the mapping</span>
        <span class="n">atom_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># We need the elements of the lanthanides, actinides, and transition</span>
        <span class="c1"># metals as we don&#39;t want to exclude radicals in these blocks.</span>
        <span class="n">d_and_f_block_elements</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
            <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">39</span><span class="p">,</span> <span class="mi">49</span><span class="p">),</span>
            <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">57</span><span class="p">,</span> <span class="mi">81</span><span class="p">),</span>
            <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">89</span><span class="p">,</span> <span class="mi">113</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">rda</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="c1"># See issues #1075 for some discussion on radicals</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">rda</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_and_f_block_elements</span>
                <span class="ow">and</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetNumRadicalElectrons</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">RadicalsNotSupportedError</span><span class="p">(</span>
                    <span class="s2">&quot;The OpenFF Toolkit does not currently support parsing molecules with S- and P-block radicals. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">rda</span><span class="o">.</span><span class="n">GetNumRadicalElectrons</span><span class="p">()</span><span class="si">}</span><span class="s2"> radical electrons on molecule </span><span class="si">{</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="n">rd_idx</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="c1"># if the molecule was made from a mapped smiles this has been hidden</span>
            <span class="c1"># so that it does not affect the sterochemistry tags</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">map_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rda</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_map_idx&quot;</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">map_id</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span>

            <span class="c1"># create a new atom</span>
            <span class="n">atomic_number</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span>
            <span class="c1"># implicit units of elementary charge</span>
            <span class="n">formal_charge</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetFormalCharge</span><span class="p">()</span>
            <span class="n">is_aromatic</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">rda</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># check for PDB names</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetMonomerInfo</span><span class="p">()</span><span class="o">.</span><span class="n">GetName</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="c1"># If chiral, store the chirality to be set later</span>
            <span class="n">stereochemistry</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># tag = rda.GetChiralTag()</span>
            <span class="k">if</span> <span class="n">rda</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">):</span>
                <span class="n">stereo_code</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span>
                <span class="c1"># if tag == Chem.CHI_TETRAHEDRAL_CCW:</span>
                <span class="k">if</span> <span class="n">stereo_code</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                    <span class="n">stereochemistry</span> <span class="o">=</span> <span class="s2">&quot;R&quot;</span>
                <span class="c1"># if tag == Chem.CHI_TETRAHEDRAL_CW:</span>
                <span class="k">elif</span> <span class="n">stereo_code</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                    <span class="n">stereochemistry</span> <span class="o">=</span> <span class="s2">&quot;S&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">UndefinedStereochemistryError</span><span class="p">(</span>
                        <span class="s2">&quot;In from_rdkit: Expected atom stereochemistry of R or S. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">stereo_code</span><span class="si">}</span><span class="s2"> instead.&quot;</span>
                    <span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">rda</span><span class="o">.</span><span class="n">GetPDBResidueInfo</span><span class="p">()</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">GetResidueName</span><span class="p">()</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">GetResidueNumber</span><span class="p">()</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;insertion_code&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">GetInsertionCode</span><span class="p">()</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;chain_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">GetChainId</span><span class="p">()</span>

            <span class="n">atom_index</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">_add_atom</span><span class="p">(</span>
                <span class="n">atomic_number</span><span class="p">,</span>
                <span class="n">formal_charge</span><span class="p">,</span>
                <span class="n">is_aromatic</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="n">stereochemistry</span><span class="o">=</span><span class="n">stereochemistry</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">invalidate_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">map_atoms</span><span class="p">[</span><span class="n">rd_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom_index</span>
            <span class="n">atom_mapping</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_id</span>

        <span class="n">offmol</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>

        <span class="c1"># If we have a full / partial atom map add it to the molecule. Zeroes 0</span>
        <span class="c1"># indicates no mapping</span>
        <span class="k">if</span> <span class="p">{</span><span class="o">*</span><span class="n">atom_mapping</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span> <span class="o">!=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}:</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">_properties</span><span class="p">[</span><span class="s2">&quot;atom_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">idx</span><span class="p">:</span> <span class="n">map_idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">map_idx</span> <span class="ow">in</span> <span class="n">atom_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_idx</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="p">}</span>

        <span class="c1"># Similar to chirality, stereochemistry of bonds in OE is set relative to their neighbors</span>
        <span class="k">for</span> <span class="n">rdb</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">rdb_idx</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetEndAtomIdx</span><span class="p">()</span>

            <span class="c1"># Determine bond aromaticity and Kekulized bond order</span>
            <span class="n">is_aromatic</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">()</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetBondTypeAsDouble</span><span class="p">()</span>
            <span class="c1"># Convert floating-point bond order to integral bond order</span>
            <span class="n">order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

            <span class="c1"># create a new bond</span>
            <span class="n">bond_index</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">_add_bond</span><span class="p">(</span>
                <span class="n">map_atoms</span><span class="p">[</span><span class="n">a1</span><span class="p">],</span>
                <span class="n">map_atoms</span><span class="p">[</span><span class="n">a2</span><span class="p">],</span>
                <span class="n">order</span><span class="p">,</span>
                <span class="n">is_aromatic</span><span class="o">=</span><span class="n">is_aromatic</span><span class="p">,</span>
                <span class="n">invalidate_cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">map_bonds</span><span class="p">[</span><span class="n">rdb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_index</span>

        <span class="n">offmol</span><span class="o">.</span><span class="n">_invalidate_cached_properties</span><span class="p">()</span>

        <span class="c1"># Now fill in the cached (structure-dependent) properties. We have to have the 2D</span>
        <span class="c1"># structure of the molecule in place first, because each call to add_atom and</span>
        <span class="c1"># add_bond invalidates all cached properties</span>
        <span class="k">for</span> <span class="n">rdb</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">rdb_idx</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">offb_idx</span> <span class="o">=</span> <span class="n">map_bonds</span><span class="p">[</span><span class="n">rdb_idx</span><span class="p">]</span>
            <span class="n">offb</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">bonds</span><span class="p">[</span><span class="n">offb_idx</span><span class="p">]</span>
            <span class="c1"># determine if stereochemistry is needed</span>
            <span class="c1"># Note that RDKit has 6 possible values of bond stereo: CIS, TRANS, E, Z, ANY, or NONE</span>
            <span class="c1"># The logic below assumes that &quot;ANY&quot; and &quot;NONE&quot; mean the same thing.</span>
            <span class="n">stereochemistry</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOZ</span><span class="p">:</span>
                <span class="n">stereochemistry</span> <span class="o">=</span> <span class="s2">&quot;Z&quot;</span>
            <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOE</span><span class="p">:</span>
                <span class="n">stereochemistry</span> <span class="o">=</span> <span class="s2">&quot;E&quot;</span>
            <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOTRANS</span> <span class="ow">or</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOCIS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected RDKit bond stereochemistry of E or Z, got </span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s2"> instead&quot;</span>
                <span class="p">)</span>
            <span class="n">offb</span><span class="o">.</span><span class="n">_stereochemistry</span> <span class="o">=</span> <span class="n">stereochemistry</span>
            <span class="n">fractional_bond_order</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">rdb</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;fractional_bond_order&quot;</span><span class="p">):</span>
                <span class="n">fractional_bond_order</span> <span class="o">=</span> <span class="n">rdb</span><span class="o">.</span><span class="n">GetDoubleProp</span><span class="p">(</span><span class="s2">&quot;fractional_bond_order&quot;</span><span class="p">)</span>
            <span class="n">offb</span><span class="o">.</span><span class="n">fractional_bond_order</span> <span class="o">=</span> <span class="n">fractional_bond_order</span>

        <span class="c1"># TODO: Save conformer(s), if present</span>
        <span class="c1"># If the rdmol has a conformer, store its coordinates</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetConformers</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetConformers</span><span class="p">():</span>
                <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">offmol</span><span class="o">.</span><span class="n">n_atoms</span>
                <span class="c1"># Here we assume this always be angstrom</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">rd_idx</span><span class="p">,</span> <span class="n">off_idx</span> <span class="ow">in</span> <span class="n">map_atoms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">atom_coords</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">GetPositions</span><span class="p">()[</span><span class="n">rd_idx</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">positions</span><span class="p">[</span><span class="n">off_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">atom_coords</span>
                <span class="n">offmol</span><span class="o">.</span><span class="n">_add_conformer</span><span class="p">(</span><span class="n">Quantity</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">))</span>

        <span class="n">partial_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">offmol</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">any_atom_has_partial_charge</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">rd_idx</span><span class="p">,</span> <span class="n">rd_atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
            <span class="n">off_idx</span> <span class="o">=</span> <span class="n">map_atoms</span><span class="p">[</span><span class="n">rd_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rd_atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;PartialCharge&quot;</span><span class="p">):</span>
                <span class="n">charge</span> <span class="o">=</span> <span class="n">rd_atom</span><span class="o">.</span><span class="n">GetDoubleProp</span><span class="p">(</span><span class="s2">&quot;PartialCharge&quot;</span><span class="p">)</span>
                <span class="n">partial_charges</span><span class="p">[</span><span class="n">off_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge</span>
                <span class="n">any_atom_has_partial_charge</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If some other atoms had partial charges but this one doesn&#39;t, raise an Exception</span>
                <span class="k">if</span> <span class="n">any_atom_has_partial_charge</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Some atoms in rdmol have partial charges, but others do not.&quot;</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="n">any_atom_has_partial_charge</span><span class="p">:</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">partial_charges</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offmol</span><span class="o">.</span><span class="n">partial_charges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">offmol</span>

    <span class="nd">@cached</span><span class="p">(</span><span class="n">LRUCache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">4096</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">base_wrapper</span><span class="o">.</span><span class="n">_mol_to_ctab_and_aro_key</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_connection_table_to_rdkit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">DEFAULT_AROMATICITY_MODEL</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="k">if</span> <span class="n">aromaticity_model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ALLOWED_AROMATICITY_MODELS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidAromaticityModelError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Given aromaticity model </span><span class="si">{</span><span class="n">aromaticity_model</span><span class="si">}</span><span class="s2"> which is not in the set of allowed aromaticity models: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ALLOWED_AROMATICITY_MODELS</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create an editable RDKit molecule</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">()</span>

        <span class="n">_bondtypes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span>
            <span class="mf">1.5</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">AROMATIC</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">TRIPLE</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">QUADRUPLE</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">QUINTUPLE</span><span class="p">,</span>
            <span class="mi">6</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">HEXTUPLE</span><span class="p">,</span>
            <span class="mi">7</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">ONEANDAHALF</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">rdatom</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">formal_charge</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">))</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetIsAromatic</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">)</span>

            <span class="c1"># Stereo handling code moved to after bonds are added</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                <span class="n">rdatom</span><span class="o">.</span><span class="n">SetChiralTag</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">CHI_TETRAHEDRAL_CW</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                <span class="n">rdatom</span><span class="o">.</span><span class="n">SetChiralTag</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">CHI_TETRAHEDRAL_CCW</span><span class="p">)</span>

            <span class="c1"># Stop rdkit from adding implicit hydrogens</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetNoImplicit</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">rd_index</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">(</span><span class="n">rdatom</span><span class="p">)</span>

            <span class="c1"># Let&#39;s make sure al the atom indices in the two molecules</span>
            <span class="c1"># are the same, otherwise we need to create an atom map.</span>
            <span class="k">assert</span> <span class="n">index</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span>
            <span class="k">assert</span> <span class="n">index</span> <span class="o">==</span> <span class="n">rd_index</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">atom_indices</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rdmol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="o">*</span><span class="n">atom_indices</span><span class="p">)</span>
            <span class="n">rdbond</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">atom_indices</span><span class="p">)</span>
            <span class="c1"># Assign bond type, which is based on order unless it is aromatic</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">is_aromatic</span><span class="p">:</span>
                <span class="n">rdbond</span><span class="o">.</span><span class="n">SetBondType</span><span class="p">(</span><span class="n">_bondtypes</span><span class="p">[</span><span class="mf">1.5</span><span class="p">])</span>
                <span class="n">rdbond</span><span class="o">.</span><span class="n">SetIsAromatic</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rdbond</span><span class="o">.</span><span class="n">SetBondType</span><span class="p">(</span><span class="n">_bondtypes</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">bond_order</span><span class="p">])</span>
                <span class="n">rdbond</span><span class="o">.</span><span class="n">SetIsAromatic</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ALL</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_ADJUSTHS</span> <span class="o">^</span> <span class="n">Chem</span><span class="o">.</span><span class="n">SANITIZE_SETAROMATICITY</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">aromaticity_model</span> <span class="o">==</span> <span class="s2">&quot;OEAroModel_MDL&quot;</span><span class="p">:</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">SetAromaticity</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AromaticityModel</span><span class="o">.</span><span class="n">AROMATICITY_MDL</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidAromaticityModelError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Given aromaticity model </span><span class="si">{</span><span class="n">aromaticity_model</span><span class="si">}</span><span class="s2"> which is not in the set of allowed aromaticity models:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ALLOWED_AROMATICITY_MODELS</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Assign atom stereochemsitry and collect atoms for which RDKit</span>
        <span class="c1"># can&#39;t figure out chirality. The _CIPCode property of these atoms</span>
        <span class="c1"># will be forcefully set to the stereo we want (see #196).</span>
        <span class="n">undefined_stereo_atoms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">rdatom</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="c1"># Skip non-chiral atoms.</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Let&#39;s randomly assign this atom&#39;s (local) stereo to CW</span>
            <span class="c1"># and check if this causes the (global) stereo to be set</span>
            <span class="c1"># to the desired one (S or R).</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetChiralTag</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">CHI_TETRAHEDRAL_CW</span><span class="p">)</span>
            <span class="c1"># We need to do force and cleanIt to recalculate CIP stereo.</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># If our random initial assignment worked, then we&#39;re set.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">rdatom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">rdatom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Otherwise, set it to CCW.</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetChiralTag</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">CHI_TETRAHEDRAL_CCW</span><span class="p">)</span>
            <span class="c1"># We need to do force and cleanIt to recalculate CIP stereo.</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Hopefully this worked, otherwise something&#39;s wrong</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">rdatom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">rdatom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Keep track of undefined stereo atoms. We&#39;ll force stereochemistry</span>
            <span class="c1"># at the end to avoid the next AssignStereochemistry to overwrite.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">rdatom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">):</span>
                <span class="n">undefined_stereo_atoms</span><span class="p">[</span><span class="n">rdatom</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span>
                <span class="k">continue</span>

            <span class="c1"># Something is wrong.</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Unknown atom stereochemistry encountered in to_rdkit. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Desired stereochemistry: </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">stereochemistry</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Set stereochemistry </span><span class="si">{</span><span class="n">rdatom</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s1">&#39;_CIPCode&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="c1"># Copy bond stereo info from molecule to rdmol.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_rdmol_bonds_stereo</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># Cleanup the rdmol</span>
        <span class="n">rdmol</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">GetSSSR</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># Forcefully assign stereo information on the atoms that RDKit</span>
        <span class="c1"># can&#39;t figure out. This must be done last as calling AssignStereochemistry</span>
        <span class="c1"># again will delete these properties (see #196).</span>
        <span class="k">for</span> <span class="n">rdatom</span><span class="p">,</span> <span class="n">stereochemistry</span> <span class="ow">in</span> <span class="n">undefined_stereo_atoms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s2">&quot;_CIPCode&quot;</span><span class="p">,</span> <span class="n">stereochemistry</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rdmol</span>

    <span class="k">def</span> <span class="nf">to_rdkit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_AROMATICITY_MODEL</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an RDKit molecule</span>
<span class="sd">        Requires the RDKit to be installed.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        aromaticity_model</span>
<span class="sd">            The aromaticity model to use. Only OEAroModel_MDL is supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        rdmol</span>
<span class="sd">            An RDKit molecule</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Convert a molecule to RDKit</span>
<span class="sd">        &gt;&gt;&gt; from openff.toolkit import Molecule</span>
<span class="sd">        &gt;&gt;&gt; ethanol = Molecule.from_smiles(&#39;CCO&#39;)</span>
<span class="sd">        &gt;&gt;&gt; rdmol = ethanol.to_rdkit()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span><span class="p">,</span> <span class="n">Geometry</span>

        <span class="k">if</span> <span class="n">aromaticity_model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ALLOWED_AROMATICITY_MODELS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidAromaticityModelError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Given aromaticity model </span><span class="si">{</span><span class="n">aromaticity_model</span><span class="si">}</span><span class="s2"> which is not in the set of allowed aromaticity models: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ALLOWED_AROMATICITY_MODELS</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Convert the OFF molecule&#39;s connectivity table to RDKit, returning a cached rdmol if possible</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_table_to_rdkit</span><span class="p">(</span>
            <span class="n">molecule</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span>
        <span class="p">)</span>
        <span class="c1"># In case a cached rdmol was returned, make a copy of it</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
        <span class="c1"># Set name</span>
        <span class="c1"># TODO: What is the best practice for how this should be named?</span>
        <span class="k">if</span> <span class="n">molecule</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">rdmol</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">,</span> <span class="n">molecule</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># TODO: Set other properties</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">rdmol</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">rdmol</span><span class="o">.</span><span class="n">SetIntProp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">rdmol</span><span class="o">.</span><span class="n">SetDoubleProp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">rdmol</span><span class="o">.</span><span class="n">SetBoolProp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Shove everything else into a string</span>
                <span class="n">rdmol</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">rdatom</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">rdatom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rdatom</span><span class="o">.</span><span class="n">GetPDBResidueInfo</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AtomPDBResidueInfo</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">rdatom</span><span class="o">.</span><span class="n">GetPDBResidueInfo</span><span class="p">()</span>

            <span class="n">atom_has_any_metadata</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># RDKit is very naive about PDB atom names - Needs them to be exactly</span>
            <span class="c1"># 4 characters or the columns won&#39;t comply with PDB specification</span>
            <span class="n">res</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">4</span><span class="p">)[:</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;residue_name&quot;</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
                <span class="n">atom_has_any_metadata</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">res</span><span class="o">.</span><span class="n">SetResidueName</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_name&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;residue_number&quot;</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
                <span class="n">atom_has_any_metadata</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">res</span><span class="o">.</span><span class="n">SetResidueNumber</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;residue_number&quot;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="s2">&quot;insertion_code&quot;</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
                <span class="n">atom_has_any_metadata</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">res</span><span class="o">.</span><span class="n">SetInsertionCode</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;insertion_code&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;chain_id&quot;</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
                <span class="n">atom_has_any_metadata</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">res</span><span class="o">.</span><span class="n">SetChainId</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;chain_id&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">atom_has_any_metadata</span><span class="p">:</span>
                <span class="n">rdatom</span><span class="o">.</span><span class="n">SetPDBResidueInfo</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">atom_indices</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
                <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rdbond</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">atom_indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">fractional_bond_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rdbond</span><span class="o">.</span><span class="n">SetDoubleProp</span><span class="p">(</span>
                    <span class="s2">&quot;fractional_bond_order&quot;</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">fractional_bond_order</span>
                <span class="p">)</span>

        <span class="c1"># Set coordinates if we have them</span>
        <span class="k">if</span> <span class="n">molecule</span><span class="o">.</span><span class="n">_conformers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">_conformers</span><span class="p">:</span>
                <span class="n">rdmol_conformer</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Conformer</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">atom_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">conformer</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">angstrom</span><span class="p">)</span>
                    <span class="n">rdmol_conformer</span><span class="o">.</span><span class="n">SetAtomPosition</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">,</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">Point3D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
                <span class="n">rdmol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">rdmol_conformer</span><span class="p">,</span> <span class="n">assignId</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Retain charges, if present</span>
        <span class="k">if</span> <span class="n">molecule</span><span class="o">.</span><span class="n">_partial_charges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rdk_indexed_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">molecule</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom_idx</span><span class="p">,</span> <span class="n">charge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">molecule</span><span class="o">.</span><span class="n">_partial_charges</span><span class="p">):</span>
                <span class="n">charge_unitless</span> <span class="o">=</span> <span class="n">charge</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span><span class="p">)</span>
                <span class="n">rdk_indexed_charges</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">charge_unitless</span>
            <span class="k">for</span> <span class="n">atom_idx</span><span class="p">,</span> <span class="n">rdk_atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
                <span class="n">rdk_atom</span><span class="o">.</span><span class="n">SetDoubleProp</span><span class="p">(</span><span class="s2">&quot;PartialCharge&quot;</span><span class="p">,</span> <span class="n">rdk_indexed_charges</span><span class="p">[</span><span class="n">atom_idx</span><span class="p">])</span>

            <span class="c1"># Note: We could put this outside the &quot;if&quot; statement, which would result in all partial charges in the</span>
            <span class="c1">#       resulting file being set to &quot;n/a&quot; if they weren&#39;t set in the Open Force Field Toolkit ``Molecule``</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">CreateAtomDoublePropertyList</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="s2">&quot;PartialCharge&quot;</span><span class="p">)</span>

        <span class="c1"># Return non-editable version</span>
        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_inchi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InChI string for the molecule using the RDKit Toolkit.</span>
<span class="sd">        InChI is a standardised representation that does not capture tautomers</span>
<span class="sd">        unless specified using the fixed hydrogen layer.</span>

<span class="sd">        For information on InChi see here https://iupac.org/who-we-are/divisions/division-details/inchi/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule to convert into a SMILES.</span>

<span class="sd">        fixed_hydrogens</span>
<span class="sd">            If a fixed hydrogen layer should be added to the InChI, if `True` this will produce a</span>
<span class="sd">            non standard specific InChI string of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        inchi</span>
<span class="sd">            The InChI string of the molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        EmptyInChiError</span>
<span class="sd">            If RDKit failed to generate an InChI for the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed_hydrogens</span><span class="p">:</span>
            <span class="n">inchi</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToInchi</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="s2">&quot;-FixedH&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inchi</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToInchi</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inchi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EmptyInChiError</span><span class="p">(</span><span class="s2">&quot;RDKit failed to generate an InChI for the molecule.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inchi</span>

    <span class="k">def</span> <span class="nf">to_inchikey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">fixed_hydrogens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an InChIKey for the molecule using the RDKit Toolkit.</span>
<span class="sd">        InChIKey is a standardised representation that does not capture tautomers</span>
<span class="sd">        unless specified using the fixed hydrogen layer.</span>

<span class="sd">        For information on InChi see here https://iupac.org/who-we-are/divisions/division-details/inchi/</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule to convert into a SMILES.</span>

<span class="sd">        fixed_hydrogens</span>
<span class="sd">            If a fixed hydrogen layer should be added to the InChI, if `True` this will</span>
<span class="sd">            produce a non standard specific InChI string of the molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        inchi_key</span>
<span class="sd">            The InChIKey representation of the molecule.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        EmptyInChiError</span>
<span class="sd">            If RDKit failed to generate an InChI for the molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed_hydrogens</span><span class="p">:</span>
            <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToInchiKey</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="s2">&quot;-FixedH&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inchi_key</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToInchiKey</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inchi_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EmptyInChiError</span><span class="p">(</span>
                <span class="s2">&quot;RDKit failed to generate an InChI key for the molecule.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">inchi_key</span>

    <span class="k">def</span> <span class="nf">get_tagged_smarts_connectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smarts</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of tuples indicating connectivity between tagged atoms in a SMARTS string. Does not</span>
<span class="sd">        return bond order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smarts</span>
<span class="sd">            The tagged SMARTS to analyze</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unique_tags</span>
<span class="sd">            A sorted tuple of all unique tagged atom map indices.</span>
<span class="sd">        tagged_atom_connectivity</span>
<span class="sd">            A tuple of tuples, where each inner tuple is a pair of tagged atoms (tag_idx_1, tag_idx_2)</span>
<span class="sd">             which are bonded. The inner tuples are ordered smallest-to-largest, and the tuple of</span>
<span class="sd">             tuples is ordered lexically. So the return value for an improper torsion would be</span>
<span class="sd">             ((1, 2), (2, 3), (2, 4)).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SMIRKSParsingError</span>
<span class="sd">            If RDKit was unable to parse the provided smirks/tagged smarts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.exceptions</span> <span class="kn">import</span> <span class="n">SMIRKSParsingError</span>

        <span class="n">ss</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is a SMIRKS or SMARTS parsing error? The argument and exception disagree</span>
            <span class="k">raise</span> <span class="n">SMIRKSParsingError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;RDKit was unable to parse SMIRKS/SMARTS </span><span class="si">{</span><span class="n">smarts</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">_unique_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">_connections</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">at1</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">at1</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">_unique_tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">at1</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">at2</span> <span class="ow">in</span> <span class="n">at1</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">at2</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">cxn_to_add</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">at1</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">(),</span> <span class="n">at2</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()])</span>
                <span class="n">_connections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cxn_to_add</span><span class="p">))</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_connections</span><span class="p">)))</span>
        <span class="n">unique_tags</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_unique_tags</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">unique_tags</span><span class="p">,</span> <span class="n">connections</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_smarts_matches</span><span class="p">(</span>
        <span class="n">rdmol</span><span class="p">,</span>
        <span class="n">smarts</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">aromaticity_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;OEAroModel_MDL&quot;</span><span class="p">,</span>
        <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find all sets of atoms in the provided RDKit molecule that match the provided SMARTS string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol</span>
<span class="sd">            rdmol to process with the SMIRKS in order to find matches</span>
<span class="sd">        smarts</span>
<span class="sd">            SMARTS string with any number of sequentially tagged atoms.</span>
<span class="sd">            If there are N tagged atoms numbered 1..N, the resulting matches will be</span>
<span class="sd">            N-tuples of atoms that match the corresponding tagged atoms.</span>
<span class="sd">        aromaticity_model</span>
<span class="sd">            OpenEye aromaticity model designation as a string, such as ``OEAroModel_MDL``.</span>
<span class="sd">            Molecule is prepared with this aromaticity model prior to querying.</span>
<span class="sd">        unique</span>
<span class="sd">            If True, only return unique matches. If False, return all matches. This is passed to</span>
<span class="sd">            RDKit&#39;s ``GetSubstructMatches`` as ``uniquify``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matches</span>
<span class="sd">            matches[index] is an N-tuple of atom numbers from the ``rdmol``</span>
<span class="sd">            Matches are returned in no guaranteed order.</span>
<span class="sd">            # TODO: What is returned if no matches are found? An empty list, or None?</span>
<span class="sd">            # TODO: Ensure that SMARTS numbers 1, 2, 3... are rendered into order of</span>
<span class="sd">            #    returned matches indexed by 0, 1, 2...</span>

<span class="sd">        .. notes ::</span>

<span class="sd">           * Raises ``ChemicalEnvironmentParsingError`` if ``smarts`` query is malformed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="kn">from</span> <span class="nn">openff.toolkit.utils.exceptions</span> <span class="kn">import</span> <span class="n">ChemicalEnvironmentParsingError</span>

        <span class="c1"># This code is part of a possible performance optimization that hasn&#39;t been validated</span>
        <span class="c1"># for production use yet.</span>
        <span class="k">def</span> <span class="nf">_match_smarts_with_heavy_atoms_first</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">qmol</span><span class="p">,</span> <span class="n">match_kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">SetIntProp</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="n">remove_params</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">rdmolops</span><span class="o">.</span><span class="n">RemoveHsParameters</span><span class="p">()</span>
            <span class="n">remove_params</span><span class="o">.</span><span class="n">removeWithQuery</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">heavy_query</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">qmol</span><span class="p">,</span> <span class="n">remove_params</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">heavy_to_qmol</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">GetIntProp</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">heavy_query</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="n">query_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">heavy_to_qmol</span><span class="p">))]</span>

            <span class="n">full_matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">heavy_match</span> <span class="ow">in</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">heavy_query</span><span class="p">,</span> <span class="o">**</span><span class="n">match_kwargs</span><span class="p">):</span>
                <span class="n">rdmol_copy</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
                <span class="n">qmol_copy</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">(</span><span class="n">qmol</span><span class="p">)</span>
                <span class="c1"># pin atoms by atom type</span>
                <span class="k">for</span> <span class="n">heavy_index</span><span class="p">,</span> <span class="n">rdmol_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">heavy_match</span><span class="p">):</span>
                    <span class="n">qmol_index</span> <span class="o">=</span> <span class="n">heavy_to_qmol</span><span class="p">[</span><span class="n">heavy_index</span><span class="p">]</span>
                    <span class="n">qmol_copy</span><span class="o">.</span><span class="n">ReplaceAtom</span><span class="p">(</span><span class="n">qmol_index</span><span class="p">,</span> <span class="n">query_atoms</span><span class="p">[</span><span class="n">heavy_index</span><span class="p">])</span>
                    <span class="n">rdmol_copy</span><span class="o">.</span><span class="n">ReplaceAtom</span><span class="p">(</span><span class="n">rdmol_index</span><span class="p">,</span> <span class="n">query_atoms</span><span class="p">[</span><span class="n">heavy_index</span><span class="p">])</span>

                <span class="n">rdmol_copy</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">qmol_copy</span><span class="o">.</span><span class="n">UpdatePropertyCache</span><span class="p">(</span><span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">h_matches</span> <span class="o">=</span> <span class="n">rdmol_copy</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">qmol_copy</span><span class="p">,</span> <span class="o">**</span><span class="n">match_kwargs</span><span class="p">)</span>
                <span class="n">full_matches</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">h_matches</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">full_matches</span>

        <span class="c1"># Set up query.</span>
        <span class="n">qmol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmarts</span><span class="p">(</span><span class="n">smarts</span><span class="p">)</span>  <span class="c1"># cannot catch the error</span>
        <span class="k">if</span> <span class="n">qmol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ChemicalEnvironmentParsingError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;RDKit could not parse the SMARTS/SMIRKS string &quot;</span><span class="si">{</span><span class="n">smarts</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Create atom mapping for query molecule</span>
        <span class="n">idx_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">qmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="n">smirks_index</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetAtomMapNum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">smirks_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx_map</span><span class="p">[</span><span class="n">smirks_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
        <span class="n">map_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx_map</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx_map</span><span class="p">)]</span>

        <span class="c1"># choose the largest unsigned int without overflow</span>
        <span class="c1"># since the C++ signature is a uint</span>
        <span class="c1"># TODO: max_matches = int(max_matches) if max_matches is not None else np.iinfo(np.uintc).max</span>
        <span class="n">max_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uintc</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="n">match_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">uniquify</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">max_matches</span><span class="p">,</span> <span class="n">useChirality</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># These variables are un-used, do they serve a purpose?</span>
        <span class="c1"># n_heavy = qmol.GetNumHeavyAtoms()</span>
        <span class="c1"># n_h = qmol.GetNumAtoms() - n_heavy</span>
        <span class="c1"># TODO: if match_heavy_first: full_matches = _match_smarts_with_heavy_atoms_first(...)</span>
        <span class="n">full_matches</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetSubstructMatches</span><span class="p">(</span><span class="n">qmol</span><span class="p">,</span> <span class="o">**</span><span class="n">match_kwargs</span><span class="p">)</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">map_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">full_matches</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">matches</span>

    <span class="k">def</span> <span class="nf">find_smarts_matches</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span>
        <span class="n">smarts</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">aromaticity_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;OEAroModel_MDL&quot;</span><span class="p">,</span>
        <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all SMARTS matches for the specified molecule, using the specified aromaticity model.</span>

<span class="sd">        .. warning :: This API is experimental and subject to change.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        molecule</span>
<span class="sd">            The molecule for which all specified SMARTS matches are to be located</span>
<span class="sd">        smarts</span>
<span class="sd">            SMARTS string with optional SMIRKS-style atom tagging</span>
<span class="sd">        aromaticity_model</span>
<span class="sd">            Molecule is prepared with this aromaticity model prior to querying.</span>
<span class="sd">        unique</span>
<span class="sd">            If True, only return unique matches. If False, return all matches.</span>

<span class="sd">        .. note :: Currently, the only supported ``aromaticity_model`` is ``OEAroModel_MDL``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_table_to_rdkit</span><span class="p">(</span>
            <span class="n">molecule</span><span class="p">,</span> <span class="n">aromaticity_model</span><span class="o">=</span><span class="n">aromaticity_model</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_smarts_matches</span><span class="p">(</span>
            <span class="n">rdmol</span><span class="p">,</span>
            <span class="n">smarts</span><span class="p">,</span>
            <span class="n">aromaticity_model</span><span class="o">=</span><span class="s2">&quot;OEAroModel_MDL&quot;</span><span class="p">,</span>
            <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">atom_is_in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">:</span> <span class="s2">&quot;Atom&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether or not an atom is in a ring.</span>

<span class="sd">        It is assumed that this atom is in molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom</span>
<span class="sd">            The molecule containing the atom of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_in_ring</span>
<span class="sd">            Whether or not the atom is in a ring.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotAttachedToMoleculeError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAttachedToMoleculeError</span><span class="p">(</span>
                <span class="s2">&quot;This Atom does not belong to a Molecule object&quot;</span>
            <span class="p">)</span>

        <span class="n">molecule</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">molecule</span>
        <span class="n">atom_index</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">molecule_atom_index</span>

        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>
        <span class="n">rdatom</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">atom_index</span><span class="p">)</span>

        <span class="n">is_in_ring</span> <span class="o">=</span> <span class="n">rdatom</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">is_in_ring</span>

    <span class="k">def</span> <span class="nf">bond_is_in_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">:</span> <span class="s2">&quot;Bond&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return whether or not a bond is in a ring.</span>

<span class="sd">        It is assumed that this atom is in molecule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bond</span>
<span class="sd">            The molecule containing the atom of interest</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_in_ring</span>
<span class="sd">            Whether or not the bond of index `bond_index` is in a ring</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotAttachedToMoleculeError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">molecule</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotAttachedToMoleculeError</span><span class="p">(</span>
                <span class="s2">&quot;This Bond does not belong to a Molecule object&quot;</span>
            <span class="p">)</span>

        <span class="n">molecule</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">molecule</span>
        <span class="n">rdmol</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">to_rdkit</span><span class="p">()</span>

        <span class="c1"># Molecule.to_rdkit() is NOT guaranteed to preserve bond ordering,</span>
        <span class="c1"># so we must look up the corresponding bond via its constituent atom indices</span>
        <span class="n">rdbond</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2_index</span><span class="p">)</span>
        <span class="n">is_in_ring</span> <span class="o">=</span> <span class="n">rdbond</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">is_in_ring</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_undefined_stereo_atoms</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">assign_stereo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the chiral atoms with undefined stereochemsitry in the RDMol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol</span>
<span class="sd">            The RDKit molecule.</span>
<span class="sd">        assign_stereo</span>
<span class="sd">            As a side effect, this function calls ``Chem.AssignStereochemistry()``</span>
<span class="sd">            so by default we work on a molecule copy. Set this to ``True`` to avoid</span>
<span class="sd">            making a copy and assigning the stereochemistry to the Mol object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        undefined_atom_indices</span>
<span class="sd">            A list of atom indices that are chiral centers with undefined</span>
<span class="sd">            stereochemistry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rdkit.Chem.FindMolChiralCenters</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assign_stereo</span><span class="p">:</span>
            <span class="c1"># Avoid modifying the original molecule.</span>
            <span class="n">rdmol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># Flag possible chiral centers with the &quot;_ChiralityPossible&quot;.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rdmol</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flagPossibleStereoCenters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Find all atoms with undefined stereo.</span>
        <span class="n">undefined_atom_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom_idx</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetChiralTag</span><span class="p">()</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">ChiralType</span><span class="o">.</span><span class="n">CHI_UNSPECIFIED</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span>
                <span class="s2">&quot;_ChiralityPossible&quot;</span>
            <span class="p">):</span>
                <span class="n">undefined_atom_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">undefined_atom_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_undefined_stereo_bonds</span><span class="p">(</span><span class="n">rdmol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the chiral atoms with undefined stereochemsitry in the RDMol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol</span>
<span class="sd">            The RDKit molecule.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        undefined_bond_indices</span>
<span class="sd">            A list of bond indices with undefined stereochemistry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Chem.EnumerateStereoisomers._getFlippers</span>

<span class="sd">        Links</span>
<span class="sd">        -----</span>
<span class="sd">        https://github.com/rdkit/rdkit/blob/master/Code/GraphMol/Chirality.cpp#L1509-L1515</span>
<span class="sd">            This comment in FindPotentialStereoBonds mention that the method</span>
<span class="sd">            ignores ring bonds.</span>
<span class="sd">        https://github.com/DrrDom/rdk/blob/master/gen_stereo_rdkit3.py</span>
<span class="sd">            The function get_unspec_double_bonds() in this module looks like</span>
<span class="sd">            may solve the problem with the rings.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="c1"># Copy the molecule to avoid side effects. Chem.FindPotentialStereoBonds</span>
        <span class="c1"># assign Bond.STEREOANY to unspecific bond, which make subsequent calls</span>
        <span class="c1"># of Chem.AssignStereochemistry ignore the bond even if there are</span>
        <span class="c1"># ENDDOWNRIGHT/ENDUPRIGHT bond direction indications.</span>
        <span class="n">rdmol_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="c1"># Clear any previous assignments on the bonds, since FindPotentialStereo may not overwrite it</span>
        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">rdmol_copy</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
            <span class="n">bond</span><span class="o">.</span><span class="n">SetStereo</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREONONE</span><span class="p">)</span>

        <span class="c1"># This function assigns Bond.GetStereo() == Bond.STEREOANY to bonds with</span>
        <span class="c1"># possible stereochemistry.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">FindPotentialStereoBonds</span><span class="p">(</span><span class="n">rdmol_copy</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Any TRULY stereogenic bonds in the molecule are now marked as STEREOANY in rdmol_copy.</span>
        <span class="c1"># Iterate through all the bonds, and for the ones where rdmol_copy is marked as STEREOANY,</span>
        <span class="c1"># ensure that they are cis/trans/E/Z (tested here be ensuring that they&#39;re NOT either</span>
        <span class="c1"># # of the other possible types (NONE or ANY))</span>
        <span class="n">undefined_bond_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bond_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">orig_bond</span><span class="p">,</span> <span class="n">repercieved_bond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">(),</span> <span class="n">rdmol_copy</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="c1"># print(repercieved_bond.GetStereo(), orig_bond.GetStereo())</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">repercieved_bond</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">()</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOANY</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">orig_bond</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">()</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOANY</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">orig_bond</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">()</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREONONE</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">undefined_bond_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">undefined_bond_indices</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_detect_undefined_stereo</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">rdmol</span><span class="p">,</span>
        <span class="n">err_msg_prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raise UndefinedStereochemistryError if the RDMol has undefined stereochemistry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rdmol</span>
<span class="sd">            The RDKit molecule.</span>
<span class="sd">        err_msg_prefix</span>
<span class="sd">            A string to prepend to the error message (but not the warning).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UndefinedStereochemistryError</span>
<span class="sd">            If the RDMol has undefined atom or bond stereochemistry.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find undefined atom/bond stereochemistry.</span>
        <span class="n">undefined_atom_indices</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_find_undefined_stereo_atoms</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>
        <span class="n">undefined_bond_indices</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_find_undefined_stereo_bonds</span><span class="p">(</span><span class="n">rdmol</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undefined_atom_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">undefined_bond_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;RDMol has unspecified stereochemistry. &quot;</span>
        <span class="c1"># The &quot;_Name&quot; property is not always assigned.</span>
        <span class="k">if</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;RDMol name: &quot;</span> <span class="o">+</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_Name&quot;</span><span class="p">)</span>

        <span class="c1"># Details about undefined atoms.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undefined_atom_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;Undefined chiral centers are:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">undefined_atom_idx</span> <span class="ow">in</span> <span class="n">undefined_atom_indices</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; - Atom </span><span class="si">{</span><span class="n">rdmol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">undefined_atom_idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span><span class="si">}</span><span class="s2"> (index </span><span class="si">{</span><span class="n">undefined_atom_idx</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># Details about undefined bond.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">undefined_bond_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;Bonds with undefined stereochemistry are:</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">undefined_bond_idx</span> <span class="ow">in</span> <span class="n">undefined_bond_indices</span><span class="p">:</span>
                <span class="n">bond</span> <span class="o">=</span> <span class="n">rdmol</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="n">undefined_bond_idx</span><span class="p">)</span>
                <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBeginAtom</span><span class="p">(),</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetEndAtom</span><span class="p">()</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot; - Bond </span><span class="si">{</span><span class="n">undefined_bond_idx</span><span class="si">}</span><span class="s2"> (atoms </span><span class="si">{</span><span class="n">atom1</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">atom2</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span><span class="si">}</span><span class="s2"> of element &quot;</span>
                    <span class="s2">&quot;({atom1.GetSymbol()}-{atom2.GetSymbol()})</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">raise</span> <span class="n">UndefinedStereochemistryError</span><span class="p">(</span><span class="n">err_msg_prefix</span> <span class="o">+</span> <span class="n">msg</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_constrain_end_directions</span><span class="p">(</span>
        <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bond_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">flip_direction</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A constraint applied when mapping global E/Z stereochemistry into local RDKit</span>
<span class="sd">        bond directions that ensures that the &#39;left&#39; bonds point in opposite directions</span>
<span class="sd">        (i.e. one has to be up and one has to be down) and likewise for the &#39;right&#39; bonds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Account for bond &quot;direction&quot; using flip_directions dict, see more thorough comment</span>
        <span class="c1"># in _constrain_rank for details.</span>
        <span class="n">bond_directions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">value</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">flip_direction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bond_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">unique_bond_directions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bond_directions</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_bond_directions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_constrain_rank</span><span class="p">(</span>
        <span class="o">*</span><span class="n">values</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">bond_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">flip_direction</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span>
        <span class="n">expected_stereo</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A constraint applied when mapping global E/Z stereochemistry into local RDKit</span>
<span class="sd">        bond directions that ensures that the &#39;left&#39; bond with the highest CIP rank</span>
<span class="sd">        and the &#39;right&#39; bond with the highest CIP rank point either in the same direction</span>
<span class="sd">        if Z stereo or opposite directions if E.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The &quot;value&quot; for each bond is ultimately set to either 0 (down) or 1 (up).</span>
        <span class="c1"># However, we also need to know the &quot;direction&quot; of the bond to make sense</span>
        <span class="c1"># of this - Is it coming FROM, or going TO this double bond while going down or up?</span>
        <span class="c1"># This information is in the flipped_values dict. This code assumes that the</span>
        <span class="c1"># &quot;normal&quot; case is when the neighboring bonds are coming FROM the double bond,</span>
        <span class="c1"># and where that&#39;s not true, the following line switches the</span>
        <span class="c1"># meaning of &quot;down&quot; and &quot;up&quot; to give us the desired meaning.</span>
        <span class="n">bond_directions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">value</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">flip_direction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bond_indices</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Test for equality of items in flipped_values by turning it into a set and</span>
        <span class="c1"># counting how many values remain.</span>
        <span class="n">unique_bond_directions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bond_directions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expected_stereo</span> <span class="o">==</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_bond_directions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_indices</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">expected_stereo</span> <span class="o">==</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_bond_directions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_assign_rdmol_bonds_stereo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">off_molecule</span><span class="p">:</span> <span class="s2">&quot;Molecule&quot;</span><span class="p">,</span> <span class="n">rd_molecule</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy the info about bonds stereochemistry from the OFF Molecule to RDKit Mol.</span>
<span class="sd">        The method proceeds by formulating mapping global E/Z stereo information onto</span>
<span class="sd">        local &#39;bond directions&#39; as a constraint satisfaction problem (CSP).</span>
<span class="sd">        In this formalism, the variables correspond to the indices of the bonds</span>
<span class="sd">        neighbouring a stereogenic bond, the domain for each variable is 0 (down)</span>
<span class="sd">        or 1 (up), and the constraints are designed to ensure the correct E/Z stereo</span>
<span class="sd">        is yielded after assignment of the directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">constraint</span> <span class="kn">import</span> <span class="n">Problem</span>
        <span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>

        <span class="n">_RD_STEREO_TO_STR</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOE</span><span class="p">:</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span>
            <span class="n">Chem</span><span class="o">.</span><span class="n">BondStereo</span><span class="o">.</span><span class="n">STEREOZ</span><span class="p">:</span> <span class="s2">&quot;Z&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">stereogenic_bonds</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">bond</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">off_molecule</span><span class="o">.</span><span class="n">bonds</span> <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">stereochemistry</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stereogenic_bonds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Needed to ensure the _CIPRank is present. Note that, despite the kwargs that look like</span>
        <span class="c1"># they could mangle existing stereo, it is actually preserved.</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span>
            <span class="n">rd_molecule</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flagPossibleStereoCenters</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">csp_problem</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">()</span>
        <span class="n">csp_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">stereogenic_bonds</span><span class="p">:</span>
            <span class="c1"># Here we use a notation where atoms &#39;b&#39; and &#39;c&#39; are the two atoms involved</span>
            <span class="c1"># in the double bond, while &#39;a&#39; corresponds to a neighbour of &#39;b&#39; and &#39;d&#39; a</span>
            <span class="c1"># neighbour of &#39;c&#39;.</span>
            <span class="n">atom_b</span><span class="p">,</span> <span class="n">atom_c</span> <span class="o">=</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom1</span><span class="p">,</span> <span class="n">bond</span><span class="o">.</span><span class="n">atom2</span>
            <span class="n">index_b</span><span class="p">,</span> <span class="n">index_c</span> <span class="o">=</span> <span class="n">atom_b</span><span class="o">.</span><span class="n">molecule_atom_index</span><span class="p">,</span> <span class="n">atom_c</span><span class="o">.</span><span class="n">molecule_atom_index</span>

            <span class="n">indices_a</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">n</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom_b</span><span class="o">.</span><span class="n">bonded_atoms</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">atom_c</span>
            <span class="p">]</span>
            <span class="n">indices_d</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">n</span><span class="o">.</span><span class="n">molecule_atom_index</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom_c</span><span class="o">.</span><span class="n">bonded_atoms</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">atom_b</span>
            <span class="p">]</span>
            <span class="c1"># A stereogenic double bond should either involve atoms with degree 3</span>
            <span class="c1"># (e.g. carbon) or degree 2 (e.g. divalent nitrogen).</span>
            <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_d</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>

            <span class="c1"># Identify the highest CIP-ranked bond coming off each side of the double</span>
            <span class="c1"># bond. This lets us later add a constraint to ensure that we have the</span>
            <span class="c1"># correct E/Z stereochemistry</span>
            <span class="n">ranks_a</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPRank&quot;</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_a</span>
            <span class="p">]</span>
            <span class="n">index_a</span> <span class="o">=</span> <span class="n">indices_a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ranks_a</span><span class="p">)]</span>
            <span class="n">ranks_d</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">GetProp</span><span class="p">(</span><span class="s2">&quot;_CIPRank&quot;</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_d</span>
            <span class="p">]</span>
            <span class="n">index_d</span> <span class="o">=</span> <span class="n">indices_d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ranks_d</span><span class="p">)]</span>

            <span class="n">index_ab</span> <span class="o">=</span> <span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">index_a</span><span class="p">,</span> <span class="n">index_b</span><span class="p">)</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
            <span class="n">index_cd</span> <span class="o">=</span> <span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">index_c</span><span class="p">,</span> <span class="n">index_d</span><span class="p">)</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>

            <span class="n">flip_direction</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># Collect lists of the indices of the bonds that appear to the &#39;left&#39; of</span>
            <span class="c1"># and &#39;right&#39; of the stereogenic bond so we can constrain their directions</span>
            <span class="c1"># so that all &#39;left&#39; bonds do not, for example, point up.</span>
            <span class="n">constraints_ab</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">constraints_cd</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">index_pair</span><span class="p">,</span> <span class="n">constraints_list</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">((</span><span class="n">index_a</span><span class="p">,</span> <span class="n">index_b</span><span class="p">),</span> <span class="n">constraints_ab</span><span class="p">)</span> <span class="k">for</span> <span class="n">index_a</span> <span class="ow">in</span> <span class="n">indices_a</span>
            <span class="p">]</span> <span class="o">+</span> <span class="p">[((</span><span class="n">index_d</span><span class="p">,</span> <span class="n">index_c</span><span class="p">),</span> <span class="n">constraints_cd</span><span class="p">)</span> <span class="k">for</span> <span class="n">index_d</span> <span class="ow">in</span> <span class="n">indices_d</span><span class="p">]:</span>
                <span class="c1"># Each single bond neighboring a double bond needs to be defined as a</span>
                <span class="c1"># &quot;variable&quot; in the CSP problem. Here, each bond is identified by its</span>
                <span class="c1"># bond index in the RDMol (note: this is not guaranteed to be the same</span>
                <span class="c1"># as the corresponding bond&#39;s index in the OFFMol). This also ensures</span>
                <span class="c1"># that we don&#39;t define the same bond twice.</span>
                <span class="n">rd_bond</span> <span class="o">=</span> <span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="o">*</span><span class="n">index_pair</span><span class="p">)</span>
                <span class="n">rd_bond_index</span> <span class="o">=</span> <span class="n">rd_bond</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">rd_bond_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">csp_variables</span><span class="p">:</span>
                    <span class="n">csp_problem</span><span class="o">.</span><span class="n">addVariable</span><span class="p">(</span><span class="n">rd_bond_index</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># 0 = down, 1 = up</span>
                    <span class="n">csp_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rd_bond_index</span><span class="p">)</span>

                <span class="c1"># The direction of the bond should point from the double bond to its</span>
                <span class="c1"># neighbour. If the bond is pointing from the neighbour to the double</span>
                <span class="c1"># bond instead, we need to flip the direction of the bond. See</span>
                <span class="c1"># rdkit/Code/GraphMol/Chirality.cpp:findAtomNeighborDirHelper for more</span>
                <span class="c1"># details.</span>
                <span class="n">flip_direction</span><span class="p">[</span><span class="n">rd_bond_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rd_bond</span><span class="o">.</span><span class="n">GetBeginAtomIdx</span><span class="p">()</span> <span class="o">!=</span> <span class="n">index_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">constraints_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rd_bond_index</span><span class="p">)</span>

            <span class="c1"># Add one constraint corresponding to the highest-ranked bond on OPPOSITE</span>
            <span class="c1"># sides of the double bond, to ensure that they are oriented up/down to</span>
            <span class="c1"># achieve the correct E/Z value of the double bond.</span>
            <span class="n">csp_problem</span><span class="o">.</span><span class="n">addConstraint</span><span class="p">(</span>
                <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_constrain_rank</span><span class="p">,</span>
                    <span class="n">bond_indices</span><span class="o">=</span><span class="p">[</span><span class="n">index_ab</span><span class="p">,</span> <span class="n">index_cd</span><span class="p">],</span>
                    <span class="n">flip_direction</span><span class="o">=</span><span class="n">flip_direction</span><span class="p">,</span>
                    <span class="n">expected_stereo</span><span class="o">=</span><span class="n">bond</span><span class="o">.</span><span class="n">stereochemistry</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="p">[</span><span class="n">index_ab</span><span class="p">,</span> <span class="n">index_cd</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="c1"># Add constraint(s) corresponding ALL bonds on the SAME side of the double</span>
            <span class="c1"># bond, to ensure that they do not all take the same value (if one is &quot;up&quot;,</span>
            <span class="c1"># the other can not also be &quot;up&quot;).</span>
            <span class="n">csp_problem</span><span class="o">.</span><span class="n">addConstraint</span><span class="p">(</span>
                <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_constrain_end_directions</span><span class="p">,</span>
                    <span class="n">bond_indices</span><span class="o">=</span><span class="n">constraints_ab</span><span class="p">,</span>
                    <span class="n">flip_direction</span><span class="o">=</span><span class="n">flip_direction</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">constraints_ab</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">csp_problem</span><span class="o">.</span><span class="n">addConstraint</span><span class="p">(</span>
                <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_constrain_end_directions</span><span class="p">,</span>
                    <span class="n">bond_indices</span><span class="o">=</span><span class="n">constraints_cd</span><span class="p">,</span>
                    <span class="n">flip_direction</span><span class="o">=</span><span class="n">flip_direction</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">constraints_cd</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Do not assume that every solution found by the solver is valid.</span>
        <span class="c1"># Iterate through the solutions and ensure that the</span>
        <span class="c1"># desired E/Z marks have really been achieved.</span>
        <span class="n">has_solution</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">csp_problem</span><span class="o">.</span><span class="n">getSolutionIter</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rd_bond_index</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">rd_bond</span> <span class="o">=</span> <span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetBondWithIdx</span><span class="p">(</span><span class="n">rd_bond_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">rd_bond</span><span class="o">.</span><span class="n">SetBondDir</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">BondDir</span><span class="o">.</span><span class="n">ENDDOWNRIGHT</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">rd_bond</span><span class="o">.</span><span class="n">SetBondDir</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">BondDir</span><span class="o">.</span><span class="n">ENDUPRIGHT</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

            <span class="n">Chem</span><span class="o">.</span><span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rd_molecule</span><span class="p">,</span> <span class="n">cleanIt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Verify that there are no stereo mismatches between the original</span>
            <span class="c1"># OFFMol and the newly-assigned RDMol</span>
            <span class="n">stereo_mismatch</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">off_bond</span> <span class="ow">in</span> <span class="n">stereogenic_bonds</span><span class="p">:</span>
                <span class="n">rd_bond</span> <span class="o">=</span> <span class="n">rd_molecule</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span>
                    <span class="n">off_bond</span><span class="o">.</span><span class="n">atom1_index</span><span class="p">,</span> <span class="n">off_bond</span><span class="o">.</span><span class="n">atom2_index</span>
                <span class="p">)</span>
                <span class="n">rd_stereo_string</span> <span class="o">=</span> <span class="n">_RD_STEREO_TO_STR</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rd_bond</span><span class="o">.</span><span class="n">GetStereo</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">off_bond</span><span class="o">.</span><span class="n">stereochemistry</span> <span class="o">!=</span> <span class="n">rd_stereo_string</span><span class="p">:</span>
                    <span class="n">stereo_mismatch</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">stereo_mismatch</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">has_solution</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>

        <span class="k">assert</span> <span class="n">has_solution</span><span class="p">,</span> <span class="s2">&quot;E/Z stereo could not be converted to local stereo&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Hannah Turney. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.1.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>